<!DOCTYPE html><html lang="pt-BR"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://qph.cf2.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' data: blob: https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self' data: blob:; upgrade-insecure-requests; block-all-mixed-content; report-uri https://www.quora.com/poe_api/csp_report_3RD_PARTY_POST; report-to csp-endpoint;">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Linha do Tempo Histórica</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <style>
    :root {
      --primary-color: #2196f3;
      --primary-dark: #1565C0;
      --error-color: #f44336;
      --bg-color: #f0f2f5;
      --text-color: #333;
      --card-bg: #fff;
      --border-color: #ddd;
      --shadow-color: rgba(0,0,0,0.1);
      --banner-text: white;
      --scrollbar-track: #ddd;
      --scrollbar-thumb: #2196f3;
      --grid-line-color: rgba(0,0,0,0.05);
    }

    .dark {
      --primary-color: #4676E0;
      --primary-dark: #3060C0;
      --error-color: #f44336;
      --bg-color: #121212;
      --text-color: #e0e0e0;
      --card-bg: #242424;
      --border-color: #444;
      --shadow-color: rgba(0,0,0,0.3);
      --banner-text: #f0f0f0;
      --scrollbar-track: #333;
      --scrollbar-thumb: #4676E0;
      --grid-line-color: rgba(255,255,255,0.05);
    }

    .event-flag {
      z-index: 10;
    }

    .person-event {
      z-index: 5;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background-color: var(--bg-color);
      min-height: 100vh;
      padding: 2rem;
      color: var(--text-color);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .timeline-container {
      width: 100%;
      height: 100vh;
      overflow-x: auto;
      overflow-y: hidden;
      padding: 40px 0;
      position: fixed;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      padding-bottom: 40px;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      cursor: grab;
      touch-action: pan-x pinch-zoom;
    }

    .timeline-container::-webkit-scrollbar {
      height: 8px;
      width: 0;
    }

    .timeline-container::-webkit-scrollbar-track {
      background: var(--scrollbar-track);
      border-radius: 4px;
    }

    .timeline-container::-webkit-scrollbar-thumb {
      background: var(--scrollbar-thumb);
      border-radius: 4px;
    }

    .timeline-container {
      scrollbar-width: thin;
      scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
    }

    .timeline-horizontal {
      position: absolute;
      bottom: 40px;
      width: 100%;
      min-width: 100%;
      padding: 20px;
      counter-reset: person-index;
      transform: translateY(0);
      transition: width 0.3s ease;
    }

    .timeline-line {
      position: absolute;
      height: 6px;
      background-color: var(--primary-color);
      bottom: 50%;
      left: 0;
      right: 0;
      transform: translateY(50%);
      border-radius: 3px;
    }

    .center-marker-line {
      position: absolute;
      height: 20px;
      width: 4px;
      background: var(--primary-color);
      bottom: calc(50% - 10px);
      left: calc(((4499) / 7000) * 100%);
      transform: translate(-50%, 0);
      z-index: 2;
    }

    .event {
      position: absolute;
      transform: translate(-50%, -50%);
      width: auto;
      cursor: pointer;
    }

    .event.top {
      top: -60px;
    }

    .event.bottom {
      top: 60px;
    }

    .event-content { /* Estilo base para todos os event-content */
      display: none;
      background: var(--card-bg);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 8px var(--shadow-color);
      transition: transform 0.3s ease;
      color: var(--text-color);
      /* z-index será definido especificamente para cada tipo se necessário */
    }

    .event-flag-banner {
      display: none;
      font-size: 10px;
      padding: 2px 6px;
    }

    /* Restaurado para tooltip original da bandeira */
    .event-flag:hover .event-flag-banner {
      display: block;
      background-color: var(--event-color);
      opacity: 0.8;
      color: var(--banner-text);
      white-space: nowrap;
      box-shadow: 0 2px 4px var(--shadow-color);
      position: relative; /* Ajustar se necessário para o layout do banner */
      z-index: 15; /* Para garantir que o banner esteja acima da linha, mas abaixo do popup superior */
    }

    /* Restaurado para tooltip original da bandeira */
    .event-flag:hover .event-content { /* Este é o tooltip que aparece junto à bandeira */
      display: block;
      /* z-index já definido em .event-flag .event-content abaixo */
    }

    .person-event:hover .event-content { /* Mantido para tooltip original de personagem */
      display: block;
    }

    .event-flag {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      top: -240px;
    }

    .event-flag-line {
      width: 2px;
      background-color: var(--event-color);
      opacity: 0.7;
      height: 200px;
      position: absolute;
      top: 100%;
    }

    .event-flag-line::before {
      content: attr(data-year);
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 40px;
      background-color: var(--event-color);
      border-radius: 50%;
      opacity: 0.9;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--banner-text);
      font-size: 11px;
      white-space: nowrap;
      z-index: 3;
    }

    /* .event-flag-banner já estilizado acima no hover */

    .action-buttons {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      flex-direction: row;
      gap: 10px;
      z-index: 998;
    }

    .add-btn {
      width: 40px;
      height: 40px;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border-radius: 8px;
      transition: transform 0.3s ease;
    }

    .add-btn:hover {
      transform: scale(1.1);
    }

    .add-btn svg {
      width: 20px;
      height: 20px;
    }

    .add-person-btn {
      background: var(--primary-dark);
      color: white;
    }

    .add-event-btn {
      background: var(--primary-color);
      color: white;
    }

    .add-period-btn {
      background: var(--primary-dark);
      color: white;
    }

    .dark-mode-btn {
      background: #9013FE;
      color: white;
    }

    .stats-btn {
      background: #FF9800;
      color: white;
    }

    .keyboard-btn {
      background: #009688;
      color: white;
    }

    .help-btn {
      background: #607D8B;
      color: white;
    }
    
    .annotation-btn {
      background: #E91E63;
      color: white;
    }

    .load-btn {
      background: var(--primary-dark);
      color: white;
    }

    .save-btn {
      background: var(--primary-color);
      color: white;
    }

    .pdf-btn {
      background: #E53935;
      color: white;
    }

    .clear-btn {
      background: var(--error-color);
      color: white;
    }
    
    .settings-btn, .settings-main-btn {
      background: #673AB7;
      color: white;
    }

    .event-form {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--card-bg);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 16px var(--shadow-color);
      z-index: 1000; /* Acima do overlay, abaixo do popup de descrição superior */
      color: var(--text-color);
      max-width: 90%;
      width: 500px;
      max-height: 85vh;
      overflow-y: auto;
    }

    .event-form.active {
      display: block;
    }

    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 999; /* Abaixo do formulário */
    }

    .overlay.active {
      display: block;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
    }

    .form-group input,
    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--card-bg);
      color: var(--text-color);
    }

    .form-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .form-save-btn {
      background: var(--primary-color);
      color: white;
    }

    .form-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .cancel-btn {
      background: var(--border-color);
      color: var(--text-color);
    }

    .date-markers {
      position: absolute;
      bottom: -45px;
      left: 0;
      right: 0;
      height: 45px;
      display: flex;
      justify-content: space-between;
      color: var(--text-color);
    }

    .date-marker {
      display: flex;
      flex-direction: column;
      align-items: center;
      position: absolute;
      transform: translateX(-50%);
    }

    .date-marker span {
      position: relative;
      top: 15px;
    }

    .date-marker::before {
      content: '';
      width: 2px;
      height: 20px;
      background-color: var(--text-color);
      margin-bottom: 0;
      position: absolute;
      top: -10px;
    }

    .minor-tick {
      position: absolute;
      transform: translateX(-50%);
    }

    .minor-tick::before {
      content: '';
      width: 1px;
      height: 10px;
      background-color: var(--text-color);
      margin-bottom: 0;
      position: absolute;
      top: -5px;
    }

    .zoom-control {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--card-bg);
      padding: 10px;
      border-radius: 20px;
      box-shadow: 0 4px 8px var(--shadow-color);
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 998; /* Abaixo de outros elementos fixos superiores */
      color: var(--text-color);
    }

    .zoom-slider {
      width: 200px;
      height: 5px;
      -webkit-appearance: none;
      background: var(--border-color);
      border-radius: 5px;
      outline: none;
      transition: all 0.3s ease;
    }

    .zoom-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 15px;
      height: 15px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
    }

    .zoom-slider::-moz-range-thumb {
      width: 15px;
      height: 15px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .zoom-label {
      color: var(--text-color);
      font-size: 14px;
    }

    .life-span {
      position: absolute;
      height: 4px;
      background: var(--person-color);
      border-radius: 2px;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      opacity: 0.8;
      left: 0;
    }

    .life-span.imprecise-start {
      background: linear-gradient(to right, transparent, var(--person-color));
    }

    .life-span.imprecise-end {
      background: linear-gradient(to right, var(--person-color), transparent);
    }

    .life-span.imprecise-both {
      background: linear-gradient(to right, transparent, var(--person-color), transparent);
    }

    .person-event {
      position: absolute;
      top: calc(-24px - (var(--person-row) * 24px));
      transform: none;
      cursor: pointer;
      width: auto;
      z-index: 5; /* Base z-index para personagens */
      transition: top 0.3s ease;
      height: 24px;
      display: flex;
      align-items: center;
      min-width: 40px;
    }
    
    .person-event.locked {
      cursor: default;
    }

    .person-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--person-color);
      padding: 2px 8px;
      border-radius: 4px;
      color: var(--banner-text);
      font-size: 12px;
      white-space: nowrap;
      box-shadow: 0 1px 2px var(--shadow-color);
      line-height: 1.2;
      width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .person-event .event-content { /* Tooltip original do personagem */
      display: none;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 100%; /* Aparece acima da barra do personagem */
      margin-bottom: 10px;
      z-index: 20; /* Acima de outros elementos da timeline, mas abaixo do popup superior */
      background: var(--card-bg);
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 4px 15px var(--shadow-color);
      min-width: 200px;
      border: 1px solid var(--border-color);
    }

    .person-event:hover {
      z-index: 15; /* Aumenta z-index no hover para sobrepor outros personagens não-hovered */
    }

    .event-flag .event-content { /* Tooltip original da bandeira */
      display: none; /* Controlado por :hover */
      position: absolute;
      left: 50%;
      top: -100px; /* Ajustar conforme design, aparece acima da "cabeça" da bandeira */
      transform: translateX(-50%);
      z-index: 20; /* Acima de outros elementos da timeline, mas abaixo do popup superior */
      background: var(--card-bg);
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 4px 15px var(--shadow-color);
      min-width: 200px;
    }

    .event-flag .event-content:after { /* Seta para o tooltip da bandeira */
      content: '';
      position: absolute;
      bottom: -8px; /* Aponta para baixo, saindo do tooltip */
      left: 50%;
      transform: translateX(-50%);
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid var(--card-bg);
    }

    .person-event .event-content:after { /* Seta para o tooltip do personagem */
      content: '';
      position: absolute;
      bottom: -8px; /* Aponta para baixo, saindo do tooltip */
      left: 50%;
      transform: translateX(-50%);
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid var(--card-bg);
    }

    .context-menu {
      position: fixed;
      background: var(--card-bg);
      border-radius: 4px;
      box-shadow: 0 2px 5px var(--shadow-color);
      padding: 5px 0;
      min-width: 150px;
      z-index: 10000; /* Acima de quase tudo */
      display: none;
      color: var(--text-color);
    }

    .context-menu.active {
      display: block;
    }

    .context-menu-item {
      padding: 8px 15px;
      cursor: pointer;
      font-size: 14px;
    }

    .context-menu-item:hover {
      background: var(--bg-color);
    }

    .context-menu-item.delete {
      color: var(--error-color);
    }
    
    .context-menu-item.annotate {
      color: #E91E63;
    }
    
    .context-menu-item.toggle-lock {
      color: var(--primary-color);
    }

    .dropdown-content {
      display: none;
      position: absolute;
      top: 100%;
      right: 0;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    button.menu-btn {
      background: linear-gradient(45deg, #4A90E2, #9013FE);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: background 0.3s;
    }

    .action-buttons.active .dropdown-content {
      display: flex;
      opacity: 1;
      transform: translateY(0);
    }

    .form-row {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .form-row .form-group {
      flex: 1;
      margin-bottom: 0;
    }

    .period-overlay {
      position: absolute;
      top: -1000px;
      bottom: -1000px;
      background-color: var(--period-color);
      opacity: 0.05;
      pointer-events: auto;
      z-index: 1;
      transform: none !important;
      min-width: 10px; /* Adiciona largura mínima para períodos curtos */
    }

    .period-overlay:hover {
      opacity: 0.1;
    }

    .period-overlay:hover .event-content {
      display: block;
    }

    .period-overlay .event-content {
      display: none;
      position: absolute;
      left: 50%;
      bottom: 100%;
      margin-bottom: 10px;
      transform: translateX(-50%);
      z-index: 10;
      background: var(--card-bg);
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 4px 15px var(--shadow-color);
      min-width: 200px;
      border: 1px solid var(--border-color);
    }

    .period-overlay .event-content:after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid var(--card-bg);
    }

    .period-label {
      position: absolute;
      top: -30px;
      left: 0;
      transform: translateX(0);
      background: var(--period-color);
      color: var(--banner-text);
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 2;
    }

    .checkbox-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .checkbox-wrapper {
      display: flex;
      align-items: center;
      cursor: pointer;
    }

    .checkbox-wrapper input[type="checkbox"] {
      appearance: none;
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border: 2px solid var(--primary-color);
      border-radius: 4px;
      outline: none;
      transition: all 0.3s;
      margin-right: 8px;
      position: relative;
      cursor: pointer;
      background-color: var(--card-bg);
    }

    .checkbox-wrapper input[type="checkbox"]:checked {
      background-color: var(--primary-color);
    }

    .checkbox-wrapper input[type="checkbox"]:checked::before {
      content: '✔';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 12px;
    }

    .checkbox-wrapper label {
      font-size: 14px;
      color: var(--text-color);
      user-select: none;
    }

    .period-overlay:hover {
      opacity: 0.1;
      z-index: 4; /* Abaixo dos personagens em hover */
    }

    .period-overlay:hover .event-content {
      display: block !important;
    }

    /* Novas adições */
    .search-container {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      z-index: 998;
      width: 300px;
    }
    
    .search-input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 20px 0 0 20px;
      font-size: 14px;
      background-color: var(--card-bg);
      color: var(--text-color);
    }
    
    .search-button {
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 0 20px 20px 0;
      width: 40px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .search-results {
      position: fixed;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--card-bg);
      border-radius: 8px;
      padding: 10px;
      max-height: 300px;
      overflow-y: auto;
      width: 300px;
      box-shadow: 0 4px 8px var(--shadow-color);
      z-index: 997;
      display: none;
    }
    
    .search-results.active {
      display: block;
    }
    
    .search-result-item {
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid var(--border-color);
    }
    
    .search-result-item:hover {
      background-color: var(--bg-color);
    }
    
    .search-result-title {
      font-weight: bold;
    }
    
    .search-result-year {
      font-size: 12px;
      color: var(--primary-color);
    }
    
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 9999;
    }
    
    .toast {
      background: var(--card-bg);
      color: var(--text-color);
      border-left: 4px solid var(--primary-color);
      padding: 12px 20px;
      margin-top: 10px;
      border-radius: 4px;
      box-shadow: 0 4px 8px var(--shadow-color);
      animation: slideIn 0.3s, fadeOut 0.5s 2.5s forwards;
      max-width: 300px;
    }
    
    .toast.error {
      border-left-color: var(--error-color);
    }
    
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }
    
    .highlighted {
      animation: highlight 2s ease;
    }
    
    @keyframes highlight {
      0% { filter: brightness(1); }
      50% { filter: brightness(1.5); }
      100% { filter: brightness(1); }
    }
    
    button:focus, input:focus, textarea:focus {
      outline: 2px solid var(--primary-color);
      outline-offset: 2px;
    }

    #form-error {
      color: var(--error-color);
      margin-top: 10px;
      display: none;
    }
    
    .modal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--card-bg);
      padding: 25px;
      border-radius: 8px;
      box-shadow: 0 4px 16px var(--shadow-color);
      z-index: 1001;
      color: var(--text-color);
      max-width: 90%;
      width: 600px;
      max-height: 85vh;
      overflow-y: auto;
    }
    
    .modal.active {
      display: block;
    }
    
    .modal-title {
      font-size: 20px;
      margin-bottom: 15px;
      color: var(--primary-color);
    }
    
    .close-modal {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      font-size: 20px;
      color: var(--text-color);
      cursor: pointer;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }
    
    .close-modal:hover {
      background: var(--bg-color);
    }
    
    .stats-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .stat-card {
      background: var(--bg-color);
      border-radius: 8px;
      padding: 15px;
      flex: 1 1 calc(33% - 20px);
      min-width: 150px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    .stat-value {
      font-size: 28px;
      font-weight: bold;
      color: var(--primary-color);
    }
    
    .stat-label {
      font-size: 14px;
      color: var(--text-color);
      text-align: center;
    }
    
    .stat-chart {
      width: 100%;
      height: 200px;
      margin-top: 20px;
      background: var(--bg-color);
      border-radius: 8px;
      padding: 15px;
      position: relative;
    }
    
    .chart-bar {
      position: absolute;
      bottom: 40px;
      width: 30px;
      background: var(--primary-color);
      border-radius: 4px 4px 0 0;
      transition: height 0.5s ease;
    }
    
    .chart-label {
      position: absolute;
      bottom: 10px;
      text-align: center;
      font-size: 12px;
      color: var(--text-color);
      transform: translateX(-50%);
    }
    
    .keyboard-shortcut {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .shortcut-keys {
      display: flex;
      gap: 5px;
    }
    
    .key {
      background: var(--bg-color);
      padding: 3px 8px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      font-size: 12px;
      min-width: 25px;
      text-align: center;
    }
    
    .shortcut-description {
      color: var(--text-color);
    }
    
    .tutorial-step {
      margin-bottom: 20px;
    }
    
    .tutorial-step-number {
      display: inline-block;
      width: 24px;
      height: 24px;
      background: var(--primary-color);
      color: white;
      border-radius: 50%;
      text-align: center;
      margin-right: 10px;
      font-weight: bold;
    }
    
    .tutorial-step-title {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 16px;
    }
    
    .tutorial-image {
      max-width: 100%;
      height: auto;
      margin: 10px 0;
      border-radius: 4px;
      border: 1px solid var(--border-color);
    }
    
    /* Adicionar animações para o tutorial */
    .tutorial-highlight {
      position: absolute;
      border: 2px dashed var(--primary-color);
      border-radius: 4px;
      pointer-events: none;
      z-index: 1000;
      animation: pulse 1.5s infinite;
    }
    
    /* Nova funcionalidade: anotações */
    .annotation-pin {
      position: absolute;
      width: 20px;
      height: 20px;
      background-color: #E91E63;
      border-radius: 50%;
      cursor: pointer;
      z-index: 25;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 12px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      transform: translate(-50%, -50%);
    }
    
    .annotation-pin:hover {
      transform: translate(-50%, -50%) scale(1.2);
      z-index: 30;
    }
    
    .annotation-content {
      position: absolute;
      background: var(--card-bg);
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 4px 15px var(--shadow-color);
      z-index: 30;
      min-width: 200px;
      max-width: 300px;
      display: none;
      color: var(--text-color);
      border: 1px solid var(--border-color);
    }
    
    .annotation-pin:hover .annotation-content {
      display: block;
    }
    
    .annotation-title {
      font-weight: bold;
      margin-bottom: 5px;
      color: #E91E63;
    }
    
    .annotation-form {
      padding: 15px;
    }
    
    /* Estilos responsivos para dispositivos móveis */
    @media (max-width: 768px) {
      .action-buttons {
        bottom: 20px;
        top: auto;
        right: 20px;
      }
      
      .zoom-control {
        top: 70px;
        padding: 5px 10px;
      }
      
      .zoom-slider {
        width: 120px;
      }
      
      .search-container {
        top: 120px;
        width: 90%;
        max-width: 300px;
      }
      
      .event-form, .modal {
        width: 95%;
        max-width: none;
      }
      
      .form-row {
        flex-direction: column;
        gap: 5px;
      }
      
      .stat-card {
        flex: 1 1 100%;
      }
    }
    
    /* PDF Export Styles */
    .pdf-container {
      font-family: 'Segoe UI', sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px;
      background-color: white;
    }
    
    .pdf-header {
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 2px solid #2196f3;
    }
    
    .pdf-title {
      font-size: 28px;
      color: #1565C0;
      margin-bottom: 10px;
    }
    
    .pdf-subtitle {
      font-size: 16px;
      color: #555;
    }
    
    .pdf-timeline {
      position: relative;
      margin: 40px 0;
      padding: 20px;
      overflow: visible !important;
    }
    
    .pdf-meta {
      margin-top: 30px;
      font-size: 12px;
      color: #777;
      text-align: right;
    }
    
    .pdf-watermark {
      position: absolute;
      bottom: 20px;
      right: 20px;
      font-size: 12px;
      color: #aaa;
      opacity: 0.5;
    }
    
    /* Estilos para o novo modal de templates */
    .templates-modal {
      width: 700px;
    }
    
    .template-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .template-item {
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }
    
    .template-item:hover {
      border-color: var(--primary-color);
      transform: translateY(-5px);
      box-shadow: 0 5px 15px var(--shadow-color);
    }
    
    .template-item.active {
      border-color: var(--primary-color);
      background-color: rgba(33, 150, 243, 0.1);
    }
    
    .template-preview {
      height: 50px;
      background-color: var(--bg-color);
      margin-bottom: 10px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }
    
    .template-preview-line {
      position: absolute;
      height: 4px;
      background-color: var(--primary-color);
      left: 10px;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .template-title {
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .template-description {
      font-size: 12px;
      color: var(--text-color);
      opacity: 0.8;
    }
    
    /* Estilos para resumo por séculos */
    .century-summary {
      margin-top: 20px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }
    
    .century-header {
      display: flex;
      justify-content: space-between;
      padding: 10px 15px;
      background-color: var(--bg-color);
      border-bottom: 1px solid var(--border-color);
      font-weight: bold;
    }
    
    .century-row {
      display: flex;
      padding: 10px 15px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .century-row:last-child {
      border-bottom: none;
    }
    
    .century-label {
      flex: 0 0 150px;
      font-weight: bold;
    }
    
    .century-count {
      flex: 0 0 80px;
      text-align: center;
    }
    
    .century-events {
      flex: 1;
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(33, 150, 243, 0); }
      100% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0); }
    }

    /* Estilo para o dropdown de configurações */
    .settings-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      right: 0;
      background: var(--card-bg);
      border-radius: 8px;
      box-shadow: 0 4px 16px var(--shadow-color);
      padding: 10px 0;
      min-width: 180px;
      z-index: 1000;
      margin-top: 10px;
    }

    .settings-dropdown.active {
      display: block;
    }

    .settings-item {
      padding: 8px 15px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      color: var(--text-color);
      transition: background-color 0.2s;
    }

    .settings-item:hover {
      background-color: var(--bg-color);
    }

    .settings-item svg {
      width: 20px;
      height: 20px;
    }

    /* Estilos para autocomplete */
    .autocomplete-container {
      position: relative;
    }

    .autocomplete-suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid var(--border-color);
      border-radius: 0 0 4px 4px;
      background: var(--card-bg);
      z-index: 10;
      box-shadow: 0 4px 8px var(--shadow-color);
      display: none;
    }

    .autocomplete-suggestions.active {
      display: block;
    }

    .autocomplete-suggestion {
      padding: 8px 10px;
      cursor: pointer;
      font-size: 14px;
      border-bottom: 1px solid var(--border-color);
    }

    .autocomplete-suggestion:hover,
    .autocomplete-suggestion.selected {
      background-color: var(--bg-color);
    }
    
    /* Novos estilos para autocomplete de busca */
    .search-autocomplete {
      position: absolute;
      top: 100%;
      left: 0;
      right: 40px; /* Deixa espaço para o botão de busca */
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 0 0 8px 8px;
      box-shadow: 0 4px 8px var(--shadow-color);
      z-index: 999;
      max-height: 200px;
      overflow-y: auto;
      display: none;
    }
    
    .search-autocomplete.active {
      display: block;
    }
    
    .search-suggestion {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border-color);
      cursor: pointer;
    }
    
    .search-suggestion:hover,
    .search-suggestion.selected {
      background-color: var(--bg-color);
    }
    
    .search-suggestion-title {
      font-weight: bold;
      font-size: 14px;
    }
    
    .search-suggestion-info {
      color: var(--primary-color);
      font-size: 12px;
    }
    
    /* Estilos para gerenciador de anotações */
    .annotations-modal {
      width: 700px;
    }
    
    .annotations-list {
      margin-top: 15px;
      max-height: 400px;
      overflow-y: auto;
    }
    
    .annotation-item {
      background: var(--bg-color);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 10px;
      position: relative;
    }
    
    .annotation-item-title {
      font-weight: bold;
      margin-bottom: 5px;
      color: #E91E63;
    }
    
    .annotation-item-text {
      margin-bottom: 8px;
    }
    
    .annotation-item-meta {
      font-size: 12px;
      color: var(--text-color);
      opacity: 0.7;
    }
    
    .annotation-item-actions {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 5px;
    }
    
    .annotation-action {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-color);
      background: var(--card-bg);
      border: 1px solid var(--border-color);
    }
    
    .annotation-action:hover {
      background: var(--primary-color);
      color: white;
    }
    
    .annotation-action.delete:hover {
      background: var(--error-color);
    }
    
    /* Ajustes para layout de século na imagem */
    .century-summary-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-top: 20px;
    }
    
    .century-card {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }
    
    .century-card-header {
      display: flex;
      justify-content: space-between;
      padding: 10px 15px;
      background-color: var(--bg-color);
      border-bottom: 1px solid var(--border-color);
    }
    
    .century-card-title {
      font-weight: bold;
    }
    
    .century-card-count {
      color: var(--primary-color);
      font-weight: bold;
    }
    
    .century-card-content {
      padding: 10px 15px;
    }
    
    .century-event-item {
      display: flex;
      margin-bottom: 5px;
      font-size: 13px;
    }
    
    .century-event-year {
      flex: 0 0 60px;
      color: var(--primary-color);
    }
    
    .century-event-title {
      flex: 1;
      display: flex;
      align-items: center;
    }

    /* Background grid lines */
    .background-grid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    .vertical-grid-line {
      position: absolute;
      top: -2000px; /* Estende para o topo da página */
      height: 4000px; /* Altura grande para cobrir toda a tela */
      width: 1px;
      background-color: var(--grid-line-color, rgba(0,0,0,0.05));
    }

    /* Template background styles */
    .academic-bg {
      background-color: var(--bg-color, #f0f2f5);
      background-image: linear-gradient(0deg, rgba(66, 165, 245, 0.03) 1px, transparent 1px);
      background-size: 100% 24px;
    }

    .night-bg {
      background-color: var(--bg-color, #121212);
      background-image: radial-gradient(rgba(66, 165, 245, 0.1) 1px, transparent 1px);
      background-size: 30px 30px;
    }

    .minimal-bg {
      background-color: var(--bg-color, #f9f9f9);
    }

    .retro-bg {
      background-color: var(--bg-color, #f5f1e3);
      background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='rgba(94, 72, 53, 0.05)' fill-opacity='0.1' fill-rule='evenodd'/%3E%3C/svg%3E");
    }

    /* Novos backgrounds para templates */
    .blueprint-bg {
      background-color: var(--bg-color);
      background-image: linear-gradient(var(--grid-line-color) 1px, transparent 1px),
                        linear-gradient(90deg, var(--grid-line-color) 1px, transparent 1px);
      background-size: 20px 20px;
    }

    .dots-bg {
      background-color: var(--bg-color);
      background-image: radial-gradient(var(--grid-line-color) 1px, transparent 1px);
      background-size: 15px 15px;
    }

    .waves-bg {
      background-color: var(--bg-color);
      background-image: url("data:image/svg+xml,%3Csvg width='100' height='20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 10 C 30 20, 70 0, 100 10 L 100 0 L 0 0 Z' fill='rgba(66, 165, 245, 0.03)'/%3E%3C/svg%3E");
      background-size: 100px 20px;
    }

    .geometric-bg {
      background-color: var(--bg-color);
      background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0 L30 30 L0 60 Z' fill='rgba(66, 165, 245, 0.03)'/%3E%3Cpath d='M60 0 L30 30 L60 60 Z' fill='rgba(66, 165, 245, 0.03)'/%3E%3C/svg%3E");
      background-size: 60px 60px;
    }

    .paper-bg {
      background-color: var(--bg-color);
      background-image: linear-gradient(90deg, rgba(66, 165, 245, 0.03) 1px, transparent 1px),
                        linear-gradient(rgba(66, 165, 245, 0.03) 1px, transparent 1px);
      background-size: 40px 40px;
    }

    /* Botão de cadeado */
    .lock-all-btn {
      position: fixed;
      top: 20px;
      left: calc(50% - 220px); /* Movido mais para a esquerda para ficar afastado do zoom control */
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--primary-dark);
      color: white;
      border-radius: 8px;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 5px var(--shadow-color);
      transition: transform 0.2s;
      z-index: 998;
    }

    .lock-all-btn:hover {
      transform: scale(1.1);
    }
    
    /* Dialog de posicionamento */
    .position-dialog {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--card-bg);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 16px var(--shadow-color);
      z-index: 1001;
      color: var(--text-color);
      width: 400px;
    }
    
    .position-dialog.active {
      display: block;
    }
    
    .position-dialog h3 {
      margin-bottom: 15px;
    }
    
    .position-option {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .position-option input[type="radio"] {
      margin-right: 10px;
    }
    
    .position-dialog-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }
    
    .position-dialog-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .position-dialog-auto {
      background: var(--primary-color);
      color: white;
    }
    
    .position-dialog-below {
      background: var(--primary-dark);
      color: white;
    }

    /* Templates com linhas verticais */
    .show-vertical-lines .vertical-grid-line {
      display: block;
    }
  </style>
</head>
<body>

<div class="zoom-control">
  <span class="zoom-label">Zoom:</span>
  <input type="range" class="zoom-slider" min="0" max="100" value="0" aria-label="Controle de zoom">
  <span class="zoom-label">0%</span>
</div>

<button class="lock-all-btn" id="lock-all-btn" title="Travar/destravar todos os personagens">
  <svg viewBox="0 0 24 24" width="20" height="20">
    <path fill="currentColor" d="M18,8A2,2 0 0,1 20,10V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V10A2,2 0 0,1 6,8H15V6A3,3 0 0,0 12,3A3,3 0 0,0 9,6H7A5,5 0 0,1 12,1A5,5 0 0,1 17,6V8H18M12,17A2,2 0 0,0 14,15A2,2 0 0,0 12,13A2,2 0 0,0 10,15A2,2 0 0,0 12,17Z"></path>
  </svg>
</button>

<div class="search-container">
  <input type="text" class="search-input" placeholder="Buscar na linha do tempo..." aria-label="Buscar na linha do tempo">
  <div class="search-autocomplete"></div>
  <button class="search-button" aria-label="Buscar">
    <svg viewBox="0 0 24 24" width="20" height="20">
      <path fill="currentColor" d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
    </svg>
  </button>
</div>

<div class="search-results">
  <!-- Resultados da busca serão exibidos aqui -->
</div>

<div id="character-description-popup" style="position: fixed; top: 20px; left: 20px; padding: 10px; background: var(--card-bg); border-radius: 6px; box-shadow: 0 2px 8px var(--shadow-color); max-width: 250px; font-size: 12px; display: none; z-index: 1001; line-height: 1.4; color: var(--text-color);">
  <p id="character-popup-description-text"></p>
</div>

<div class="timeline-container" id="timeline-container">
  <div class="timeline-horizontal">
    <div class="background-grid" id="background-grid"></div>
    <div class="timeline-line"></div>
    <div class="center-marker-line" style="left: calc(((4499) / 7000) * 100%);"></div>
    <div class="date-markers"></div>
  </div>
</div>

<div id="period-description-box" style="position: fixed; top: 20px; left: 20px; padding: 12px; background: var(--card-bg); border-radius: 8px; box-shadow: 0 2px 8px var(--shadow-color); max-width: 300px; font-size: 12px; display: none; z-index: 1001; color: var(--text-color);">
  <strong id="period-title" style="font-size: 18px; display: block; margin-bottom: 8px;"></strong>
  <span id="period-years" style="color: var(--text-color);"></span>
  <p id="period-description" style="margin-top: 8px;"></p>
</div>

<div class="toast-container">
  <!-- Aqui aparecerão os toasts de notificação -->
</div>

<div class="action-buttons">
  <button class="add-btn add-person-btn" title="Adicionar Personagem" aria-label="Adicionar Personagem">
    <svg viewBox="0 0 24 24" width="24" height="24">
      <path fill="currentColor" d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0-6c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm0 7c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4zm6 5H6v-.99c.2-.72 3.3-2.01 6-2.01s5.8 1.29 6 2v1z"></path>
    </svg>
  </button>
  <button class="add-btn add-event-btn" title="Adicionar Evento" aria-label="Adicionar Evento">
    <svg viewBox="0 0 24 24" width="24" height="24">
      <path fill="currentColor" d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6z"></path>
    </svg>
  </button>
  <button class="add-btn add-period-btn" title="Adicionar Período" aria-label="Adicionar Período">
    <svg viewBox="0 0 24 24" width="24" height="24">
      <path fill="currentColor" d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V9h14v10zm0-12H5V5h14v2zM7 11h5v5H7z"></path>
    </svg>
  </button>
  <button class="add-btn settings-main-btn" title="Configurações" aria-label="Configurações">
    <svg viewBox="0 0 24 24" width="24" height="24">
      <path fill="currentColor" d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"></path>
    </svg>
    <div class="settings-dropdown">
      <div class="settings-item dark-mode-item">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <path fill="currentColor" d="M12,18V6A6,6 0 0,1 18,12A6,6 0 0,1 12,18M20,15.31L23.31,12L20,8.69V4H15.31L12,0.69L8.69,4H4V8.69L0.69,12L4,15.31V20H8.69L12,23.31L15.31,20H20V15.31Z"></path>
        </svg>
        <span>Modo Escuro</span>
      </div>
      <div class="settings-item stats-item">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <path fill="currentColor" d="M5,3H19A2,2 0 0,1 21,5V19A2,2 0 0,1 19,21H5A2,2 0 0,1 3,19V5A2,2 0 0,1 5,3M9,17H7V10H9V17M13,17H11V7H13V17M17,17H15V13H17V17Z"></path>
        </svg>
        <span>Estatísticas</span>
      </div>
      <div class="settings-item keyboard-item">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <path fill="currentColor" d="M19,10H17V8H19M19,13H17V11H19M16,10H14V8H16M16,13H14V11H16M16,17H8V15H16M7,10H5V8H7M7,13H5V11H7M8,11H10V13H8M8,8H10V10H8M11,11H13V13H11M11,8H13V10H11M20,5H4C2.89,5 2,5.89 2,7V17A2,2 0 0,0 4,19H20A2,2 0 0,0 22,17V7C22,5.89 21.1,5 20,5Z"></path>
        </svg>
        <span>Atalhos de Teclado</span>
      </div>
      <div class="settings-item template-item">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <path fill="currentColor" d="M20,11H4V8H20M20,15H13V13H20M20,19H13V17H20M11,19H4V13H11M20.33,4.67L18.67,3L17,4.67L15.33,3L13.67,4.67L12,3L10.33,4.67L8.67,3L7,4.67L5.33,3L3.67,4.67L2,3V19A2,2 0 0,0 4,21H20A2,2 0 0,0 22,19V3L20.33,4.67Z"></path>
        </svg>
        <span>Templates</span>
      </div>
      <div class="settings-item annotations-item">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <path fill="currentColor" d="M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4A2,2 0 0,0 20,2M6,9H18V11H6M14,14H6V12H14M18,8H6V6H18"></path>
        </svg>
        <span>Anotações</span>
      </div>
    </div>
  </button>
  <button class="add-btn menu-btn" title="Menu" aria-label="Menu">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="white" d="M3 6h18v2h-18v-2zm0 5h18v2h-18v-2zm0 5h18v2h-18v-2z"></path></svg>
  </button>

  <div class="dropdown-content">
    <!-- Arquivos -->
    <button class="add-btn load-btn" title="Carregar" aria-label="Carregar">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <path fill="currentColor" d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"></path>
      </svg>
    </button>
    <button class="add-btn save-btn" title="Salvar" aria-label="Salvar">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <path fill="currentColor" d="M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z"></path>
      </svg>
    </button>
    
    <!-- Exportar -->
    <button class="add-btn test-img-btn" title="Exportar como PNG" aria-label="Exportar como PNG">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <path fill="currentColor" d="M5,3A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H14.09C14.03,20.67 14,20.34 14,20A6,6 0 0,1 20,14C20.34,14 20.67,14.03 21,14.09V5C21,3.89 20.1,3 19,3H5M7,7H17V9H7V7M7,11H12V13H7V11M17,16V19H14V21H17V24L21,20L17,16Z"></path>
      </svg>
    </button>
    <button class="add-btn pdf-btn" title="Exportar como PDF" aria-label="Exportar como PDF">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <path fill="currentColor" d="M19,3A2,2 0 0,1 21,5V19A2,2 0 0,1 19,21H5A2,2 0 0,1 3,19V5A2,2 0 0,1 5,3H19M9.5,11.5H11V13.5H9.5V11.5M9.5,7.5H11V9.5H9.5V7.5M7,15H17V17H7V15M7,11.5H8V13.5H7V11.5M7,7.5H8V9.5H7V7.5Z"></path>
      </svg>
    </button>
    
    <button class="add-btn help-btn" title="Ajuda" aria-label="Ajuda">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <path fill="currentColor" d="M15.07,11.25L14.17,12.17C13.45,12.89 13,13.5 13,15H11V14.5C11,13.39 11.45,12.39 12.17,11.67L13.41,10.41C13.78,10.05 14,9.55 14,9C14,7.89 13.1,7 12,7A2,2 0 0,0 10,9H8A4,4 0 0,1 12,5A4,4 0 0,1 16,9C16,9.88 15.64,10.67 15.07,11.25M13,19H11V17H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2Z"></path>
      </svg>
    </button>
    <button class="add-btn clear-btn" title="Limpar Tudo" aria-label="Limpar Tudo">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <path fill="currentColor" d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z"></path>
      </svg>
    </button>
  </div>
</div>

<div class="overlay"></div>
<form class="event-form">
  <div class="form-group event-fields">
    <label for="event-year">Ano (use - para A.C.):</label>
    <input type="number" id="event-year" required="" class="autocomplete-input">
    <div class="autocomplete-suggestions"></div>
    <label for="event-color">Cor do Evento:</label>
    <input type="color" id="event-color" value="#4676E0">
    <label for="event-opacity">Transparência:</label>
    <input type="range" id="event-opacity" min="0" max="100" value="100" style="width: 120px;">
    <span id="event-opacity-value">100%</span>
  </div>
  <div class="form-group person-fields" style="display:none">
    <label>Personagem - Período do Personagem</label>
    <div class="form-row">
      <div class="form-group autocomplete-container">
        <label for="birth-year">Data Inicial:</label>
        <input type="number" id="birth-year" required="" class="autocomplete-input">
        <div class="autocomplete-suggestions"></div>
      </div>
      <div style="display: flex; align-items: center; padding: 0 10px;">
        <span>até</span>
      </div>
      <div class="form-group autocomplete-container">
        <label for="death-year">Data Final:</label>
        <input type="number" id="death-year" required="" class="autocomplete-input">
        <div class="autocomplete-suggestions"></div>
      </div>
    </div>
    <div class="form-row checkbox-container">
      <div class="checkbox-wrapper">
        <input type="checkbox" id="imprecise-birth">
        <label for="imprecise-birth">Data inicial aproximada</label>
      </div>
      <div class="checkbox-wrapper">
        <input type="checkbox" id="imprecise-death">
        <label for="imprecise-death">Data final aproximada</label>
      </div>
    </div>
    <label for="person-color">Cor do Personagem:</label>
    <input type="color" id="person-color" value="#4676E0">
    <label for="person-opacity">Transparência:</label>
    <input type="range" id="person-opacity" min="0" max="100" value="100" style="width: 120px;">
    <span id="person-opacity-value">100%</span>
  </div>
  <div class="form-group">
    <label for="event-title">Título:</label>
    <input type="text" id="event-title" required="">
  </div>
  <div class="form-group">
    <label for="event-description">Descrição:</label>
    <textarea id="event-description"></textarea>
  </div>
  <div id="form-error"></div>
  <div class="form-buttons">
    <button type="button" class="cancel-btn">Cancelar</button>
    <button type="submit" class="form-save-btn">Salvar</button>
  </div>
</form>

<!-- Dialog para escolher posicionamento depois de salvar -->
<div class="position-dialog" id="position-dialog">
  <h3>Como deseja posicionar o personagem?</h3>
  
  <div class="position-option">
    <input type="radio" id="position-dialog-auto" name="position-dialog" value="auto" checked="">
    <label for="position-dialog-auto">Ajustar automaticamente</label>
  </div>
  
  <div class="position-option">
    <input type="radio" id="position-dialog-below" name="position-dialog" value="below">
    <label for="position-dialog-below">Adicionar abaixo (manter outros na mesma posição)</label>
  </div>
  
  <div class="position-dialog-buttons">
    <button type="button" class="position-dialog-auto" id="position-dialog-confirm">Confirmar</button>
  </div>
</div>

<form class="event-form annotation-form" id="annotation-form">
  <h3>Adicionar Anotação</h3>
  <div class="form-group">
    <label for="annotation-title">Título:</label>
    <input type="text" id="annotation-title" required="">
  </div>
  <div class="form-group">
    <label for="annotation-text">Anotação:</label>
    <textarea id="annotation-text" required=""></textarea>
  </div>
  <div id="annotation-form-error" style="color: var(--error-color); display: none;"></div>
  <div class="form-buttons">
    <button type="button" class="cancel-btn" id="annotation-cancel">Cancelar</button>
    <button type="submit" class="form-save-btn" id="annotation-save">Salvar</button>
  </div>
</form>

<div class="context-menu">
  <div class="context-menu-item edit">Editar</div>
  <div class="context-menu-item toggle-lock" id="context-toggle-lock">Travar posição</div>
  <div class="context-menu-item annotate">Adicionar Anotação</div>
  <div class="context-menu-item delete">Apagar</div>
</div>

<!-- Modal de Estatísticas -->
<div id="stats-modal" class="modal">
  <button class="close-modal">×</button>
  <h2 class="modal-title">Estatísticas da Linha do Tempo</h2>
  <div class="stats-container">
    <div class="stat-card">
      <div class="stat-value" id="total-events">0</div>
      <div class="stat-label">Total de Eventos</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="total-persons">0</div>
      <div class="stat-label">Total de Personagens</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="total-periods">0</div>
      <div class="stat-label">Total de Períodos</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="total-annotations">0</div>
      <div class="stat-label">Total de Anotações</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="earliest-year">-</div>
      <div class="stat-label">Ano Mais Antigo</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="latest-year">-</div>
      <div class="stat-label">Ano Mais Recente</div>
    </div>
  </div>
  
  <h3>Resumo por Séculos</h3>
  <div class="century-summary-grid" id="century-content">
    <!-- Conteúdo será preenchido pelo JavaScript -->
  </div>
</div>

<!-- Modal de Atalhos de Teclado -->
<div id="keyboard-modal" class="modal">
  <button class="close-modal">×</button>
  <h2 class="modal-title">Atalhos de Teclado</h2>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description">Adicionar evento</div>
    <div class="shortcut-keys">
      <div class="key">Alt</div>
      <div class="key">E</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description">Adicionar personagem</div>
    <div class="shortcut-keys">
      <div class="key">Alt</div>
      <div class="key">P</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description">Adicionar período</div>
    <div class="shortcut-keys">
      <div class="key">Alt</div>
      <div class="key">T</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description">Salvar linha do tempo</div>
    <div class="shortcut-keys">
      <div class="key">Ctrl</div>
      <div class="key">S</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description">Carregar linha do tempo</div>
    <div class="shortcut-keys">
      <div class="key">Ctrl</div>
      <div class="key">O</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description">Exportar como PNG</div>
    <div class="shortcut-keys">
      <div class="key">Ctrl</div>
      <div class="key">I</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description">Exportar como PDF</div>
    <div class="shortcut-keys">
      <div class="key">Ctrl</div>
      <div class="key">P</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description">Alternar modo escuro</div>
    <div class="shortcut-keys">
      <div class="key">Alt</div>
      <div class="key">D</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description">Adicionar anotação</div>
    <div class="shortcut-keys">
      <div class="key">Alt</div>
      <div class="key">A</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description">Abrir ajuda</div>
    <div class="shortcut-keys">
      <div class="key">F1</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description">Aumentar zoom</div>
    <div class="shortcut-keys">
      <div class="key">+</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description">Diminuir zoom</div>
    <div class="shortcut-keys">
      <div class="key">-</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description">Navegar para esquerda</div>
    <div class="shortcut-keys">
      <div class="key">←</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description">Navegar para direita</div>
    <div class="shortcut-keys">
      <div class="key">→</div>
    </div>
  </div>
</div>

<!-- Modal de Tutorial -->
<div id="tutorial-modal" class="modal">
  <button class="close-modal">×</button>
  <h2 class="modal-title">Tutorial: Como Usar a Linha do Tempo</h2>
  
  <div class="tutorial-step">
    <span class="tutorial-step-number">1</span>
    <span class="tutorial-step-title">Navegação Básica</span>
    <p>Use o mouse para arrastar a linha do tempo horizontalmente. Gire a roda do mouse enquanto pressiona Ctrl para aumentar ou diminuir o zoom. Use os botões + e - no teclado para ajustar o zoom rapidamente.</p>
  </div>
  
  <div class="tutorial-step">
    <span class="tutorial-step-number">2</span>
    <span class="tutorial-step-title">Adicionando Conteúdo</span>
    <p>Use os botões na barra superior direita para adicionar diferentes tipos de conteúdo:</p>
    <ul>
      <li><strong>Personagem:</strong> Indivíduos com datas de nascimento e morte</li>
      <li><strong>Evento:</strong> Momentos específicos no tempo</li>
      <li><strong>Período:</strong> Intervalos de tempo com início e fim</li>
    </ul>
  </div>
  
  <div class="tutorial-step">
    <span class="tutorial-step-number">3</span>
    <span class="tutorial-step-title">Anotações</span>
    <p>Clique com o botão direito em qualquer evento ou personagem e selecione "Adicionar Anotação" para criar notas personalizadas sobre itens específicos da linha do tempo.</p>
  </div>
  
  <div class="tutorial-step">
    <span class="tutorial-step-number">4</span>
    <span class="tutorial-step-title">Personalizando Eventos</span>
    <p>Clique com o botão direito em qualquer evento ou personagem para editar ou excluir. Você pode personalizar cores e níveis de transparência.</p>
  </div>
  
  <div class="tutorial-step">
    <span class="tutorial-step-number">5</span>
    <span class="tutorial-step-title">Salvando e Compartilhando</span>
    <p>Use o menu para salvar sua linha do tempo em formato JSON. Também é possível exportar como PNG para compartilhar ou PDF para imprimir.</p>
  </div>
  
  <div class="tutorial-step">
    <span class="tutorial-step-number">6</span>
    <span class="tutorial-step-title">Dicas Avançadas</span>
    <p>Para maior eficiência, use os atalhos de teclado listados no painel "Atalhos de Teclado". Personagens podem ser reordenados verticalmente arrastando-os para cima ou para baixo.</p>
    <p>Para personagens, você pode travar/destravar a posição clicando com o botão direito sobre eles, ou usar o botão de cadeado para travar/destravar todos de uma vez.</p>
  </div>
</div>

<!-- Novo Modal de Templates -->
<div id="templates-modal" class="modal templates-modal">
  <button class="close-modal">×</button>
  <h2 class="modal-title">Templates para Linha do Tempo</h2>
  
  <div class="template-grid">
    <div class="template-item active" data-template="default" data-show-grid="false">
      <div class="template-preview">
        <div class="template-preview-line"></div>
      </div>
      <div class="template-title">Padrão</div>
      <div class="template-description">Linha do tempo clássica com todos os recursos</div>
    </div>
    
    <div class="template-item" data-template="history" data-show-grid="false">
      <div class="template-preview">
        <div class="template-preview-line" style="background-color: #8C6E63;"></div>
      </div>
      <div class="template-title">História Mundial</div>
      <div class="template-description">Focado em eventos históricos importantes</div>
    </div>
    
    <div class="template-item" data-template="biography" data-show-grid="false">
      <div class="template-preview">
        <div class="template-preview-line" style="background-color: #4CAF50;"></div>
      </div>
      <div class="template-title">Biografia</div>
      <div class="template-description">Ideal para traçar a vida de personagens</div>
    </div>
    
    <div class="template-item" data-template="project" data-show-grid="false">
      <div class="template-preview">
        <div class="template-preview-line" style="background-color: #FF5722;"></div>
      </div>
      <div class="template-title">Projeto</div>
      <div class="template-description">Para planejamento e marcos de projetos</div>
    </div>
    
    <div class="template-item" data-template="science" data-show-grid="false">
      <div class="template-preview">
        <div class="template-preview-line" style="background-color: #2196F3;"></div>
      </div>
      <div class="template-title">Ciência</div>
      <div class="template-description">Descobertas e avanços científicos</div>
    </div>
    
    <div class="template-item" data-template="blueprint" data-show-grid="true">
      <div class="template-preview blueprint-bg">
        <div class="template-preview-line" style="background-color: #3F51B5;"></div>
      </div>
      <div class="template-title">Blueprint</div>
      <div class="template-description">Estilo grade com linhas verticais alinhadas</div>
    </div>
    
    <div class="template-item" data-template="dots" data-show-grid="true">
      <div class="template-preview dots-bg">
        <div class="template-preview-line" style="background-color: #9C27B0;"></div>
      </div>
      <div class="template-title">Pontilhado</div>
      <div class="template-description">Fundo com pontos e linhas verticais</div>
    </div>
    
    <div class="template-item" data-template="waves" data-show-grid="true">
      <div class="template-preview waves-bg">
        <div class="template-preview-line" style="background-color: #FF9800;"></div>
      </div>
      <div class="template-title">Ondas</div>
      <div class="template-description">Padrão de ondas suaves com linhas</div>
    </div>
    
    <div class="template-item" data-template="geometric" data-show-grid="false">
      <div class="template-preview geometric-bg">
        <div class="template-preview-line" style="background-color: #607D8B;"></div>
      </div>
      <div class="template-title">Geométrico</div>
      <div class="template-description">Padrões geométricos sutis</div>
    </div>
    
    <div class="template-item" data-template="paper" data-show-grid="false">
      <div class="template-preview paper-bg">
        <div class="template-preview-line" style="background-color: #795548;"></div>
      </div>
      <div class="template-title">Papel</div>
      <div class="template-description">Visual tipo folha de papel milimetrado</div>
    </div>
  </div>
  
  <div class="form-buttons">
    <button type="button" class="cancel-btn">Cancelar</button>
    <button type="button" class="form-save-btn" id="apply-template">Aplicar Template</button>
  </div>
</div>

<!-- Modal de Anotações -->
<div id="annotations-modal" class="modal annotations-modal">
  <button class="close-modal">×</button>
  <h2 class="modal-title">Gerenciar Anotações</h2>
  
  <p>Clique com o botão direito em um evento ou adicione anotações diretamente na linha do tempo.</p>
  
  <button class="form-save-btn" id="add-annotation-btn" style="margin-top: 10px;">
    <svg viewBox="0 0 24 24" width="16" height="16" style="margin-right: 5px; vertical-align: middle;">
      <path fill="currentColor" d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z"></path>
    </svg>
    Adicionar Nova Anotação
  </button>
  
  <div class="annotations-list" id="annotations-list">
    <!-- Lista de anotações será preenchida pelo JavaScript -->
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const timeline = document.querySelector('.timeline-horizontal');
    const addPersonBtn = document.querySelector('.add-person-btn');
    const addEventBtn = document.querySelector('.add-event-btn');
    const addPeriodBtn = document.querySelector('.add-period-btn');
    const settingsMainBtn = document.querySelector('.settings-main-btn');
    const settingsDropdown = document.querySelector('.settings-dropdown');
    const darkModeItem = document.querySelector('.dark-mode-item');
    const statsItem = document.querySelector('.stats-item');
    const keyboardItem = document.querySelector('.keyboard-item');
    const templateItem = document.querySelector('.template-item');
    const annotationsItem = document.querySelector('.annotations-item');
    const helpBtn = document.querySelector('.help-btn');
    const eventForm = document.querySelector('.event-form');
    const annotationForm = document.getElementById('annotation-form');
    const overlay = document.querySelector('.overlay');
    const saveBtn = document.querySelector('.form-save-btn');
    const cancelBtn = document.querySelector('.cancel-btn');
    const contextMenu = document.querySelector('.context-menu');
    const contextToggleLock = document.getElementById('context-toggle-lock');
    const menuBtn = document.querySelector('.menu-btn');
    const dropdown = document.querySelector('.dropdown-content');
    const lockAllBtn = document.getElementById('lock-all-btn');
    const positionDialog = document.getElementById('position-dialog');
    const positionDialogConfirm = document.getElementById('position-dialog-confirm');
    const backgroundGrid = document.getElementById('background-grid');
    let selectedEventElement = null;
    let temporaryAnnotationPin = null;
    let allPersonsLocked = false;
    let tempNewPersonData = null;

    const characterDescriptionPopup = document.getElementById('character-description-popup');
    const characterPopupDescriptionText = document.getElementById('character-popup-description-text');

    // Caixa de descrição para períodos
    const periodDescriptionBox = document.getElementById('period-description-box');
    const periodTitleBox = document.getElementById('period-title');
    const periodYearsBox = document.getElementById('period-years');
    const periodDescBox = document.getElementById('period-description');

    // Elementos de busca
    const searchInput = document.querySelector('.search-input');
    const searchButton = document.querySelector('.search-button');
    const searchResults = document.querySelector('.search-results');
    const searchAutocomplete = document.querySelector('.search-autocomplete');

    // Elementos dos modais
    const statsModal = document.getElementById('stats-modal');
    const keyboardModal = document.getElementById('keyboard-modal');
    const tutorialModal = document.getElementById('tutorial-modal');
    const templatesModal = document.getElementById('templates-modal');
    const annotationsModal = document.getElementById('annotations-modal');
    const modalCloseButtons = document.querySelectorAll('.close-modal');

    // Armazenamento de anotações
    let annotations = [];
    
    // Templates
    let templates = {
        default: {
            name: "Padrão",
            primaryColor: "#2196f3",
            secondaryColor: "#1565C0",
            eventColor: "#4676E0",
            personColor: "#4676E0",
            periodColor: "#4676E0",
            bgClass: "",
            gridLineColor: "rgba(0,0,0,0.05)"
        },
        history: {
            name: "História Mundial",
            primaryColor: "#8C6E63",
            secondaryColor: "#5D4037",
            eventColor: "#8C6E63",
            personColor: "#795548",
            periodColor: "#A1887F",
            bgClass: "",
            gridLineColor: "rgba(0,0,0,0.05)"
        },
        biography: {
            name: "Biografia",
            primaryColor: "#4CAF50",
            secondaryColor: "#388E3C",
            eventColor: "#66BB6A",
            personColor: "#4CAF50",
            periodColor: "#81C784",
            bgClass: "",
            gridLineColor: "rgba(0,0,0,0.05)"
        },
        project: {
            name: "Projeto",
            primaryColor: "#FF5722",
            secondaryColor: "#E64A19",
            eventColor: "#FF7043",
            personColor: "#FF5722",
            periodColor: "#FFAB91",
            bgClass: "",
            gridLineColor: "rgba(0,0,0,0.05)"
        },
        science: {
            name: "Ciência",
            primaryColor: "#2196F3",
            secondaryColor: "#1976D2",
            eventColor: "#42A5F5",
            personColor: "#2196F3",
            periodColor: "#90CAF9",
            bgClass: "",
            gridLineColor: "rgba(0,0,0,0.05)"
        },
        blueprint: {
            name: "Blueprint",
            primaryColor: "#3F51B5",
            secondaryColor: "#303F9F",
            eventColor: "#3F51B5",
            personColor: "#5C6BC0",
            periodColor: "#7986CB",
            bgClass: "blueprint-bg",
            gridLineColor: "rgba(63, 81, 181, 0.15)",
            showVerticalLines: true
        },
        dots: {
            name: "Pontilhado",
            primaryColor: "#9C27B0",
            secondaryColor: "#7B1FA2",
            eventColor: "#9C27B0",
            personColor: "#AB47BC",
            periodColor: "#CE93D8",
            bgClass: "dots-bg",
            gridLineColor: "rgba(156, 39, 176, 0.12)",
            showVerticalLines: true
        },
        waves: {
            name: "Ondas",
            primaryColor: "#FF9800",
            secondaryColor: "#F57C00",
            eventColor: "#FF9800",
            personColor: "#FFB74D",
            periodColor: "#FFCC80",
            bgClass: "waves-bg",
            gridLineColor: "rgba(255, 152, 0, 0.12)",
            showVerticalLines: true
        },
        geometric: {
            name: "Geométrico",
            primaryColor: "#607D8B",
            secondaryColor: "#455A64",
            eventColor: "#607D8B",
            personColor: "#78909C",
            periodColor: "#90A4AE",
            bgClass: "geometric-bg",
            gridLineColor: "rgba(96, 125, 139, 0.08)"
        },
        paper: {
            name: "Papel",
            primaryColor: "#795548",
            secondaryColor: "#5D4037",
            eventColor: "#795548",
            personColor: "#8D6E63",
            periodColor: "#A1887F",
            bgClass: "paper-bg",
            gridLineColor: "rgba(121, 85, 72, 0.1)"
        }
    };

    // Função para travar/destravar todos os personagens
    lockAllBtn.addEventListener('click', function() {
        allPersonsLocked = !allPersonsLocked;
        
        // Atualiza o ícone do botão
        if (allPersonsLocked) {
            lockAllBtn.innerHTML = `
                <svg viewBox="0 0 24 24" width="20" height="20">
                    <path fill="currentColor" d="M12,17A2,2 0 0,0 14,15C14,13.89 13.1,13 12,13A2,2 0 0,0 10,15A2,2 0 0,0 12,17M18,8A2,2 0 0,1 20,10V20A2,2 0 0,1 18,22H6A2,2 0 0,1 4,20V10C4,8.89 4.9,8 6,8H7V6A5,5 0 0,1 12,1A5,5 0 0,1 17,6V8H18M12,3A3,3 0 0,0 9,6V8H15V6A3,3 0 0,0 12,3Z" />
                </svg>
            `;
        } else {
            lockAllBtn.innerHTML = `
                <svg viewBox="0 0 24 24" width="20" height="20">
                    <path fill="currentColor" d="M18,8A2,2 0 0,1 20,10V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V10A2,2 0 0,1 6,8H15V6A3,3 0 0,0 12,3A3,3 0 0,0 9,6H7A5,5 0 0,1 12,1A5,5 0 0,1 17,6V8H18M12,17A2,2 0 0,0 14,15A2,2 0 0,0 12,13A2,2 0 0,0 10,15A2,2 0 0,0 12,17Z" />
                </svg>
            `;
        }
        
        // Atualiza os personagens
        events.forEach(event => {
            if (event.type === 'person') {
                event.lockedPosition = allPersonsLocked;
            }
        });
        
        // Renderiza para aplicar as alterações, mas sem recalcular posições automaticamente
        renderEvents(true);
        showToast(allPersonsLocked ? "Todos os personagens travados" : "Todos os personagens destravados");
    });

    // Configuração menu de configurações
    settingsMainBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        settingsDropdown.classList.toggle('active');
    });

    // Fechar dropdown quando clicar em outro lugar
    document.addEventListener('click', (e) => {
        if (!settingsMainBtn.contains(e.target)) {
            settingsDropdown.classList.remove('active');
        }
    });

    // Configuração dos modais
    modalCloseButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            statsModal.classList.remove('active');
            keyboardModal.classList.remove('active');
            tutorialModal.classList.remove('active');
            templatesModal.classList.remove('active');
            annotationsModal.classList.remove('active');
            overlay.classList.remove('active');
        });
    });
    
    // Dialog de confirmação de posicionamento
    positionDialogConfirm.addEventListener('click', function() {
        const positionType = document.querySelector('input[name="position-dialog"]:checked').value;
        
        if (!tempNewPersonData) return;
        
        // Adicionar a informação de posicionamento
        if (positionType === 'below') {
            // Encontrar a linha mais alta ocupada atual
            let highestRow = 0;
            events.forEach(event => {
                if (event.type === 'person' && typeof event.personRow === 'number') {
                    highestRow = Math.max(highestRow, event.personRow);
                }
            });
            
            // Colocar o novo personagem abaixo dos existentes
            tempNewPersonData.personRow = highestRow + 1;
        }
        
        events.push(tempNewPersonData);
        window.events = events;
        renderEvents();
        showToast("Personagem adicionado com sucesso");
        
        // Salva automaticamente após adicionar um novo item
        localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: currentZoom }));
        
        // Limpa dados temporários e fecha o diálogo
        tempNewPersonData = null;
        positionDialog.style.display = 'none';
        overlay.classList.remove('active');
    });
    
    // Selecionar template
    document.querySelectorAll('.template-item').forEach(item => {
        item.addEventListener('click', () => {
            document.querySelectorAll('.template-item').forEach(t => t.classList.remove('active'));
            item.classList.add('active');
        });
    });
    
    // Aplicar template
    document.getElementById('apply-template').addEventListener('click', () => {
        const selectedTemplate = document.querySelector('.template-item.active').dataset.template;
        const showGrid = document.querySelector('.template-item.active').dataset.showGrid === 'true';
        const template = templates[selectedTemplate];
        
        if (template) {
            // Aplicar cores
            document.documentElement.style.setProperty('--primary-color', template.primaryColor);
            document.documentElement.style.setProperty('--primary-dark', template.secondaryColor);
            document.documentElement.style.setProperty('--grid-line-color', template.gridLineColor);
            
            // Aplicar classes de fundo
            document.body.classList.remove('academic-bg', 'night-bg', 'minimal-bg', 'retro-bg', 'blueprint-bg', 'dots-bg', 'waves-bg', 'geometric-bg', 'paper-bg');
            if (template.bgClass) {
                document.body.classList.add(template.bgClass);
            }
            
            // Definir se as linhas verticais devem ser mostradas
            if (showGrid) {
                document.body.classList.add('show-vertical-lines');
            } else {
                document.body.classList.remove('show-vertical-lines');
            }
            
            // Atualizar linhas de grade vertical se existirem
            createVerticalGridLines();
            
            // Salva as configurações
            localStorage.setItem('primaryColor', template.primaryColor);
            localStorage.setItem('secondaryColor', template.secondaryColor);
            localStorage.setItem('selectedTemplate', selectedTemplate);
            localStorage.setItem('templateBgClass', template.bgClass || '');
            localStorage.setItem('gridLineColor', template.gridLineColor);
            localStorage.setItem('showVerticalLines', showGrid.toString());
            
            showToast(`Template "${template.name}" aplicado com sucesso`);
            
            // Fecha o modal
            templatesModal.classList.remove('active');
            overlay.classList.remove('active');
        }
    });
    
    // Criar linhas de grade vertical
    function createVerticalGridLines() {
        // Limpar grade existente
        backgroundGrid.innerHTML = '';
        
        // Criar linhas verticais alinhadas com os marcadores de data
        const dateMarkers = document.querySelectorAll('.date-marker');
        const minorTicks = document.querySelectorAll('.minor-tick');
        
        // Adicionar linhas para marcadores principais
        dateMarkers.forEach(marker => {
            const left = marker.style.left;
            const line = document.createElement('div');
            line.className = 'vertical-grid-line';
            line.style.left = left;
            backgroundGrid.appendChild(line);
        });
        
        // Adicionar linhas mais finas para marcadores secundários
        minorTicks.forEach(tick => {
            const left = tick.style.left;
            const line = document.createElement('div');
            line.className = 'vertical-grid-line';
            line.style.left = left;
            line.style.opacity = '0.5';
            backgroundGrid.appendChild(line);
        });
    }

    // Itens do menu de configurações
    darkModeItem.addEventListener('click', () => {
        document.documentElement.classList.toggle('dark');
        localStorage.setItem('darkMode', document.documentElement.classList.contains('dark'));
        settingsDropdown.classList.remove('active');
    });

    statsItem.addEventListener('click', () => {
        updateStatistics();
        statsModal.classList.add('active');
        overlay.classList.add('active');
        settingsDropdown.classList.remove('active');
    });

    keyboardItem.addEventListener('click', () => {
        keyboardModal.classList.add('active');
        overlay.classList.add('active');
        settingsDropdown.classList.remove('active');
    });

    templateItem.addEventListener('click', () => {
        // Atualiza o template selecionado
        const savedTemplate = localStorage.getItem('selectedTemplate') || 'default';
        document.querySelectorAll('.template-item').forEach(item => {
            item.classList.remove('active');
            if (item.dataset.template === savedTemplate) {
                item.classList.add('active');
            }
        });
        
        templatesModal.classList.add('active');
        overlay.classList.add('active');
        settingsDropdown.classList.remove('active');
    });
    
    // Item de anotações no menu de configurações
    annotationsItem.addEventListener('click', () => {
        updateAnnotationsList();
        annotationsModal.classList.add('active');
        overlay.classList.add('active');
        settingsDropdown.classList.remove('active');
    });
    
    // Adicionar nova anotação do modal
    document.getElementById('add-annotation-btn').addEventListener('click', () => {
        annotationsModal.classList.remove('active');
        
        // Configura o modo de anotação
        showToast("Clique em qualquer parte da linha do tempo para adicionar uma anotação");
        document.getElementById('timeline-container').addEventListener('click', handleAnnotationClick);
    });

    helpBtn.addEventListener('click', () => {
        tutorialModal.classList.add('active');
        overlay.classList.add('active');
    });
    
    // Mostrar tutorial na primeira visita
    if (!localStorage.getItem('tutorialShown')) {
        setTimeout(() => {
            tutorialModal.classList.add('active');
            overlay.classList.add('active');
            localStorage.setItem('tutorialShown', 'true');
        }, 1000);
    }
    
    // Configuração de anotações    
    function handleAnnotationClick(e) {
        // Ignora se clicar em um evento existente
        if (e.target.closest('.event') || e.target.closest('.annotation-pin')) {
            return;
        }
        
        // Remove o listener para evitar múltiplos pinos
        document.getElementById('timeline-container').removeEventListener('click', handleAnnotationClick);
        
        // Calcula a posição relativa à linha do tempo
        const rect = timeline.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 100;
        const y = ((e.clientY - rect.top) / rect.height) * 100;
        
        // Cria um pino temporário
        temporaryAnnotationPin = document.createElement('div');
        temporaryAnnotationPin.className = 'annotation-pin';
        temporaryAnnotationPin.textContent = '+';
        temporaryAnnotationPin.style.left = `${x}%`;
        temporaryAnnotationPin.style.top = `${y}%`;
        temporaryAnnotationPin.dataset.x = x;
        temporaryAnnotationPin.dataset.y = y;
        
        timeline.appendChild(temporaryAnnotationPin);
        
        // Abre o formulário de anotação
        annotationForm.classList.add('active');
        overlay.classList.add('active');
    }
    
    // Manipuladores do formulário de anotação
    document.getElementById('annotation-cancel').addEventListener('click', () => {
        annotationForm.classList.remove('active');
        overlay.classList.remove('active');
        if (temporaryAnnotationPin) {
            temporaryAnnotationPin.remove();
            temporaryAnnotationPin = null;
        }
    });
    
    document.getElementById('annotation-save').addEventListener('click', (e) => {
        e.preventDefault();
        
        const title = document.getElementById('annotation-title').value.trim();
        const text = document.getElementById('annotation-text').value.trim();
        
        if (!title || !text) {
            document.getElementById('annotation-form-error').textContent = "Título e texto são obrigatórios";
            document.getElementById('annotation-form-error').style.display = "block";
            return;
        }
        
        if (temporaryAnnotationPin) {
            const x = parseFloat(temporaryAnnotationPin.dataset.x);
            const y = parseFloat(temporaryAnnotationPin.dataset.y);
            
            // Adiciona a anotação
            const annotation = {
                id: Date.now(),
                title,
                text,
                x,
                y,
                created: new Date().toISOString()
            };
            
            annotations.push(annotation);
            saveAnnotations();
            renderAnnotations();
            
            temporaryAnnotationPin.remove();
            temporaryAnnotationPin = null;
            
            showToast("Anotação adicionada com sucesso");
        }
        
        // Reseta e fecha o formulário
        document.getElementById('annotation-form-error').style.display = "none";
        document.getElementById('annotation-title').value = '';
        document.getElementById('annotation-text').value = '';
        annotationForm.classList.remove('active');
        overlay.classList.remove('active');
    });
    
    // Funções de anotação
    function renderAnnotations() {
        // Remove todas as anotações existentes
        document.querySelectorAll('.annotation-pin:not([data-temporary])').forEach(pin => pin.remove());
        
        // Adiciona as anotações
        annotations.forEach(annotation => {
            const pin = document.createElement('div');
            pin.className = 'annotation-pin';
            pin.textContent = 'i';
            pin.style.left = `${annotation.x}%`;
            pin.style.top = `${annotation.y}%`;
            pin.dataset.id = annotation.id;
            
            const content = document.createElement('div');
            content.className = 'annotation-content';
            content.innerHTML = `
                <div class="annotation-title">${sanitizeHtml(annotation.title)}</div>
                <p>${sanitizeHtml(annotation.text)}</p>
                <small>Criado em: ${new Date(annotation.created).toLocaleString()}</small>
            `;
            
            pin.appendChild(content);
            pin.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (confirm('Deseja excluir esta anotação?')) {
                    annotations = annotations.filter(a => a.id !== annotation.id);
                    saveAnnotations();
                    renderAnnotations();
                    showToast("Anotação removida");
                }
            });
            
            timeline.appendChild(pin);
        });
    }
    
    function saveAnnotations() {
        localStorage.setItem('timelineAnnotations', JSON.stringify(annotations));
    }
    
    function loadAnnotations() {
        const saved = localStorage.getItem('timelineAnnotations');
        if (saved) {
            try {
                annotations = JSON.parse(saved);
                renderAnnotations();
            } catch (e) {
                console.error("Erro ao carregar anotações:", e);
                annotations = [];
            }
        }
    }
    
    // Atualiza a lista de anotações no modal
    function updateAnnotationsList() {
        const annotationsList = document.getElementById('annotations-list');
        annotationsList.innerHTML = '';
        
        if (annotations.length === 0) {
            annotationsList.innerHTML = '<p style="padding: 20px; text-align: center; color: var(--text-color);">Nenhuma anotação encontrada</p>';
            return;
        }
        
        // Ordenar por data de criação (mais recente primeiro)
        annotations.sort((a, b) => new Date(b.created) - new Date(a.created));
        
        annotations.forEach(annotation => {
            const item = document.createElement('div');
            item.className = 'annotation-item';
            item.innerHTML = `
                <div class="annotation-item-title">${sanitizeHtml(annotation.title)}</div>
                <div class="annotation-item-text">${sanitizeHtml(annotation.text)}</div>
                <div class="annotation-item-meta">Criado em ${new Date(annotation.created).toLocaleString()}</div>
                <div class="annotation-item-actions">
                    <div class="annotation-action edit" data-id="${annotation.id}" title="Editar">
                        <svg viewBox="0 0 24 24" width="14" height="14">
                            <path fill="currentColor" d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z"></path>
                        </svg>
                    </div>
                    <div class="annotation-action delete" data-id="${annotation.id}" title="Excluir">
                        <svg viewBox="0 0 24 24" width="14" height="14">
                            <path fill="currentColor" d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z"></path>
                        </svg>
                    </div>
                </div>
            `;
            
            annotationsList.appendChild(item);
        });
        
        // Adicionar event listeners para as ações
        document.querySelectorAll('.annotation-action.edit').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const id = parseInt(e.target.closest('.annotation-action').dataset.id);
                const annotation = annotations.find(a => a.id === id);
                
                if (annotation) {
                    annotationsModal.classList.remove('active');
                    
                    document.getElementById('annotation-title').value = annotation.title;
                    document.getElementById('annotation-text').value = annotation.text;
                    
                    annotationForm.classList.add('active');
                    
                    // Sobrescrever o handler do salvar para editar em vez de criar
                    document.getElementById('annotation-save').onclick = (saveEvent) => {
                        saveEvent.preventDefault();
                        
                        const newTitle = document.getElementById('annotation-title').value.trim();
                        const newText = document.getElementById('annotation-text').value.trim();
                        
                        if (!newTitle || !newText) {
                            document.getElementById('annotation-form-error').textContent = "Título e texto são obrigatórios";
                            document.getElementById('annotation-form-error').style.display = "block";
                            return;
                        }
                        
                        // Atualiza a anotação
                        annotation.title = newTitle;
                        annotation.text = newText;
                        annotation.updated = new Date().toISOString();
                        
                        saveAnnotations();
                        renderAnnotations();
                        
                        // Reseta e fecha o formulário
                        document.getElementById('annotation-form-error').style.display = "none";
                        document.getElementById('annotation-title').value = '';
                        document.getElementById('annotation-text').value = '';
                        annotationForm.classList.remove('active');
                        overlay.classList.remove('active');
                        
                        // Restaura o handler padrão
                        document.getElementById('annotation-save').onclick = null;
                        
                        showToast("Anotação atualizada com sucesso");
                    };
                }
            });
        });
        
        document.querySelectorAll('.annotation-action.delete').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const id = parseInt(e.target.closest('.annotation-action').dataset.id);
                
                if (confirm('Tem certeza que deseja excluir esta anotação?')) {
                    annotations = annotations.filter(a => a.id !== id);
                    saveAnnotations();
                    renderAnnotations();
                    updateAnnotationsList();
                    showToast("Anotação removida");
                }
            });
        });
    }

    // Função de exibição de toasts para notificações
    function showToast(message, type = 'info') {
        const toastContainer = document.querySelector('.toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        toastContainer.appendChild(toast);
        
        setTimeout(() => {
            toast.remove();
        }, 3000);
    }
    
    // Configuração para modo escuro
    function setupDarkMode() {
        // Verifica se há preferência salva no localStorage
        const savedDarkMode = localStorage.getItem('darkMode');
        if (savedDarkMode === 'true') {
            document.documentElement.classList.add('dark');
        }
        
        // Verifica preferência do sistema
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches && savedDarkMode !== 'false') {
            document.documentElement.classList.add('dark');
        }
        
        // Listener para mudanças na preferência do sistema
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches && localStorage.getItem('darkMode') !== 'false') {
                document.documentElement.classList.add('dark');
            } else if (!event.matches && localStorage.getItem('darkMode') !== 'true') {
                document.documentElement.classList.remove('dark');
            }
        });
        
        // Carregar cores personalizadas
        const savedPrimaryColor = localStorage.getItem('primaryColor');
        const savedSecondaryColor = localStorage.getItem('secondaryColor');
        const savedGridLineColor = localStorage.getItem('gridLineColor');
        const savedBgClass = localStorage.getItem('templateBgClass');
        const showVerticalLines = localStorage.getItem('showVerticalLines') === 'true';
        
        if (savedPrimaryColor) {
            document.documentElement.style.setProperty('--primary-color', savedPrimaryColor);
        }
        
        if (savedSecondaryColor) {
            document.documentElement.style.setProperty('--primary-dark', savedSecondaryColor);
        }
        
        if (savedGridLineColor) {
            document.documentElement.style.setProperty('--grid-line-color', savedGridLineColor);
        }
        
        if (savedBgClass) {
            document.body.classList.add(savedBgClass);
        }
        
        if (showVerticalLines) {
            document.body.classList.add('show-vertical-lines');
        } else {
            document.body.classList.remove('show-vertical-lines');
        }
    }
    
    setupDarkMode();
    
    // Busca na linha do tempo com autocomplete
    function setupSearchAutocomplete() {
        // Limpa qualquer seleção atual no autocomplete
        searchInput.addEventListener('focus', () => {
            searchAutocomplete.classList.add('active');
            updateSearchSuggestions();
        });
        
        // Atualiza as sugestões quando o usuário digita
        searchInput.addEventListener('input', updateSearchSuggestions);
        
        // Fecha o autocomplete quando clica fora
        document.addEventListener('click', (e) => {
            if (!searchInput.contains(e.target) && !searchAutocomplete.contains(e.target)) {
                searchAutocomplete.classList.remove('active');
            }
        });
        
        // Teclas de navegação no autocomplete
        searchInput.addEventListener('keydown', (e) => {
            const suggestions = searchAutocomplete.querySelectorAll('.search-suggestion');
            if (!suggestions.length) return;
            
            let selected = searchAutocomplete.querySelector('.selected');
            let index = Array.from(suggestions).indexOf(selected);
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    if (selected) {
                        selected.classList.remove('selected');
                        index = (index + 1) % suggestions.length;
                    } else {
                        index = 0;
                    }
                    suggestions[index].classList.add('selected');
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    if (selected) {
                        selected.classList.remove('selected');
                        index = (index - 1 + suggestions.length) % suggestions.length;
                    } else {
                        index = suggestions.length - 1;
                    }
                    suggestions[index].classList.add('selected');
                    break;
                    
                case 'Enter':
                    if (selected) {
                        e.preventDefault();
                        const eventIndex = selected.dataset.eventIndex;
                        if (eventIndex !== undefined) {
                            scrollToEvent(parseInt(eventIndex));
                            searchAutocomplete.classList.remove('active');
                        }
                    } else {
                        performSearch();
                    }
                    break;
                    
                case 'Escape':
                    searchAutocomplete.classList.remove('active');
                    break;
            }
        });
    }
    
    function updateSearchSuggestions() {
        const searchTerm = searchInput.value.toLowerCase().trim();
        
        if (!searchTerm) {
            searchAutocomplete.innerHTML = '';
            return;
        }
        
        // Encontrar eventos correspondentes
        const matchingEvents = events.filter(event => 
            (event.title && event.title.toLowerCase().includes(searchTerm)) || 
            (event.description && event.description.toLowerCase().includes(searchTerm))
        ).slice(0, 5); // Limita a 5 resultados para não sobrecarregar
        
        if (matchingEvents.length === 0) {
            searchAutocomplete.innerHTML = '<div class="search-suggestion" style="font-style: italic; opacity: 0.7;">Nenhum resultado encontrado</div>';
            return;
        }
        
        // Constrói as sugestões
        let suggestionsHTML = '';
        matchingEvents.forEach(event => {
            let infoText = '';
            
            if (event.type === 'event') {
                infoText = formatYear(event.year);
            } else if (event.type === 'person') {
                infoText = `${formatYear(event.birthYear)} - ${formatYear(event.deathYear)}`;
            } else if (event.type === 'period') {
                infoText = `${formatYear(event.startYear)} - ${formatYear(event.endYear)}`;
            }
            
            suggestionsHTML += `
                <div class="search-suggestion" data-event-index="${events.indexOf(event)}">
                    <div class="search-suggestion-title">${sanitizeHtml(event.title)}</div>
                    <div class="search-suggestion-info">${infoText}</div>
                </div>
            `;
        });
        
        searchAutocomplete.innerHTML = suggestionsHTML;
        
        // Adiciona event listeners para clicar nas sugestões
        document.querySelectorAll('.search-suggestion').forEach(suggestion => {
            suggestion.addEventListener('click', () => {
                const eventIndex = suggestion.dataset.eventIndex;
                if (eventIndex !== undefined) {
                    scrollToEvent(parseInt(eventIndex));
                    searchAutocomplete.classList.remove('active');
                }
            });
        });
    }
    
    function performSearch() {
        const searchTerm = searchInput.value.toLowerCase().trim();
        if (!searchTerm) {
            searchResults.classList.remove('active');
            return;
        }
        
        const results = events.filter(event => 
            (event.title && event.title.toLowerCase().includes(searchTerm)) || 
            (event.description && event.description.toLowerCase().includes(searchTerm))
        );
        
        if (results.length === 0) {
            searchResults.innerHTML = '<div class="search-result-item">Nenhum resultado encontrado</div>';
            searchResults.classList.add('active');
            return;
        }
        
        let resultsHTML = '';
        results.forEach((result, index) => {
            let yearText = '';
            
            if (result.type === 'event') {
                yearText = formatYear(result.year);
            } else if (result.type === 'person') {
                yearText = `${formatYear(result.birthYear)} - ${formatYear(result.deathYear)}`;
            } else if (result.type === 'period') {
                yearText = `${formatYear(result.startYear)} - ${formatYear(result.endYear)}`;
            }
            
            resultsHTML += `
                <div class="search-result-item" data-event-index="${events.indexOf(result)}">
                    <div class="search-result-title">${sanitizeHtml(result.title)}</div>
                    <div class="search-result-year">${yearText}</div>
                </div>
            `;
        });
        
        searchResults.innerHTML = resultsHTML;
        searchResults.classList.add('active');
        
        // Adicionar event listeners para cada resultado
        document.querySelectorAll('.search-result-item').forEach(item => {
            item.addEventListener('click', () => {
                const eventIndex = item.dataset.eventIndex;
                if (eventIndex !== undefined) {
                    scrollToEvent(parseInt(eventIndex));
                    searchResults.classList.remove('active');
                }
            });
        });
    }
    
    function formatYear(year) {
        if (!year && year !== 0) return '';
        if (year < 0) return `${-year} A.C.`;
        if (year === 0) return '0';
        return `${year} D.C.`;
    }
    
    function scrollToEvent(eventIndex) {
        const event = events[eventIndex];
        if (!event) return;
        
        let position;
        if (event.type === 'event') {
            position = ((event.year + 4500) / 7000) * 100;
        } else if (event.type === 'person') {
            position = ((event.birthYear + 4500) / 7000) * 100;
        } else if (event.type === 'period') {
            position = ((event.startYear + 4500) / 7000) * 100;
        }
        
        const timelineWidth = timeline.offsetWidth;
        const containerWidth = timelineContainer.offsetWidth;
        const scrollTo = (timelineWidth * position / 100) - (containerWidth / 2);
        
        timelineContainer.scrollTo({
            left: scrollTo,
            behavior: 'smooth'
        });
        
        // Destaca o elemento encontrado
        setTimeout(() => {
            const eventElement = document.querySelector(`.event[data-event-id="${eventIndex}"]`);
            if (eventElement) {
                eventElement.classList.add('highlighted');
                setTimeout(() => {
                    eventElement.classList.remove('highlighted');
                }, 2000);
            }
        }, 500);
    }
    
    setupSearchAutocomplete();
    searchButton.addEventListener('click', performSearch);
    searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !searchAutocomplete.querySelector('.selected')) {
            performSearch();
        }
    });
    
    // Fechar resultados da busca quando clicar fora
    document.addEventListener('click', (e) => {
        if (!searchInput.contains(e.target) && !searchButton.contains(e.target) && !searchResults.contains(e.target)) {
            searchResults.classList.remove('active');
        }
    });
    
    // Função para sanitizar HTML (prevenir XSS)
    function sanitizeHtml(text) {
        const temp = document.createElement('div');
        temp.textContent = text;
        return temp.innerHTML;
    }

    // Validação de formulário aprimorada
    function validateForm(type) {
        const errorElement = document.getElementById('form-error');
        errorElement.style.display = 'none';
        
        const title = document.getElementById('event-title').value.trim();
        if (!title) {
            showFormError("O título é obrigatório");
            return false;
        }
        
        if (type === 'person') {
            const birthYear = document.getElementById('birth-year').value;
            const deathYear = document.getElementById('death-year').value;
            
            if (!birthYear || isNaN(parseInt(birthYear))) {
                showFormError("A data inicial é obrigatória e deve ser um número");
                return false;
            }
            
            if (!deathYear || isNaN(parseInt(deathYear))) {
                showFormError("A data final é obrigatória e deve ser um número");
                return false;
            }
            
            const birthYearNum = parseInt(birthYear);
            const deathYearNum = parseInt(deathYear);
            
            if (deathYearNum < birthYearNum && !(birthYearNum < 0 && deathYearNum > 0)) {
                showFormError("A data final não pode ser anterior à data inicial");
                return false;
            }
        } else if (type === 'period') {
            const startYear = document.getElementById('period-start').value;
            const endYear = document.getElementById('period-end').value;
            
            if (!startYear || isNaN(parseInt(startYear))) {
                showFormError("A data inicial é obrigatória e deve ser um número");
                return false;
            }
            
            if (!endYear || isNaN(parseInt(endYear))) {
                showFormError("A data final é obrigatória e deve ser um número");
                return false;
            }
            
            const startYearNum = parseInt(startYear);
            const endYearNum = parseInt(endYear);
            
            if (endYearNum < startYearNum && !(startYearNum < 0 && endYearNum > 0)) {
                showFormError("A data final não pode ser anterior à data inicial");
                return false;
            }
        } else {
            const year = document.getElementById('event-year').value;
            
            if (!year || isNaN(parseInt(year))) {
                showFormError("O ano é obrigatório e deve ser um número");
                return false;
            }
        }
        
        return true;
    }
    
    function showFormError(message) {
        const errorElement = document.getElementById('form-error');
        errorElement.textContent = message;
        errorElement.style.display = 'block';
    }

    let events = [];
    const zoomSlider = document.querySelector('.zoom-slider');
    const zoomLabel = document.querySelector('.zoom-label:last-child');
    let currentZoom = 0;
    const MIN_ZOOM = 0;
    const MAX_ZOOM = 100;

    window.events = events;
    window.currentZoom = currentZoom;

    // Carrega dados do localStorage
    const savedData = localStorage.getItem('timelineData');
    if (savedData) {
        try {
            const timelineData = JSON.parse(savedData);
            window.events = events = timelineData.events || [];
            window.currentZoom = currentZoom = timelineData.zoom || 0;
            zoomSlider.value = currentZoom;
            zoomLabel.textContent = currentZoom + '%';
            renderEvents();
        } catch (e) {
            console.error("Erro ao carregar dados do localStorage:", e);
            showToast("Erro ao carregar dados: " + e.message, "error");
            localStorage.removeItem('timelineData');
        }
    }
    
    // Carrega anotações
    loadAnnotations();

    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.json';
    fileInput.style.display = 'none';
    document.body.appendChild(fileInput);

    document.querySelector('.load-btn').addEventListener('click', () => {
        fileInput.value = null;
        fileInput.click();
    });

    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (eventReader) => {
                try {
                    const timelineData = JSON.parse(eventReader.target.result);
                    window.events = events = timelineData.events || [];
                    window.currentZoom = currentZoom = timelineData.zoom || 0;
                    zoomSlider.value = currentZoom;
                    zoomLabel.textContent = currentZoom + '%';
                    renderEvents();
                    showToast("Timeline carregada com sucesso");
                } catch (error) {
                    showToast("Erro ao carregar arquivo JSON: " + error.message, "error");
                    console.error(error);
                } finally {
                    fileInput.value = null;
                }
            };
            reader.readAsText(file);
        } else {
            fileInput.value = null;
        }
    });

    let isDraggingHorizontal = false;
    let startX_timeline;
    let scrollLeftTimeline;
    const timelineContainer = document.getElementById('timeline-container');

    timelineContainer.addEventListener('mousedown', (e) => {
        if (e.target.closest('.person-event[data-is-being-dragged="true"]')) return;
         if (e.target.closest('.person-event') && e.button === 0) {
            // Permite arrastar se o clique não for no event-content (tooltip) do personagem
            if (e.target.closest('.event-content')) return;
        }
        isDraggingHorizontal = true;
        timelineContainer.style.cursor = 'grabbing';
        startX_timeline = e.pageX - timelineContainer.offsetLeft;
        scrollLeftTimeline = timelineContainer.scrollLeft;
    });
    timelineContainer.addEventListener('mouseleave', () => {
        if (isDraggingHorizontal) {
            isDraggingHorizontal = false;
            timelineContainer.style.cursor = 'grab';
        }
    });
    timelineContainer.addEventListener('mouseup', () => {
        if (isDraggingHorizontal) {
            isDraggingHorizontal = false;
            timelineContainer.style.cursor = 'grab';
        }
    });
    timelineContainer.addEventListener('mousemove', (e) => {
        if (!isDraggingHorizontal) return;
        e.preventDefault();
        const x = e.pageX - timelineContainer.offsetLeft;
        const walk = (x - startX_timeline) * 2;
        timelineContainer.scrollLeft = scrollLeftTimeline - walk;
    });
    timelineContainer.addEventListener('wheel', (e) => {
        if (e.ctrlKey) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -2 : 2;
            let newZoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, currentZoom + delta));
            zoomSlider.value = newZoom;
            window.currentZoom = currentZoom = newZoom;
            zoomLabel.textContent = Math.round(newZoom) + '%';
            const actualZoom = Math.pow(2, currentZoom/25);
            const baseWidth = 100;
            timeline.style.width = `${baseWidth * actualZoom}%`;
            const eventElements = document.querySelectorAll('.event');
            eventElements.forEach(eventEl => {
                const eventId = eventEl.dataset.eventId;
                if (eventId === undefined) return;
                const eventData = events[parseInt(eventId)];
                if (!eventData) return;
                if (eventData.type === 'person') {
                    const startPos = ((eventData.birthYear + 4500) / 7000) * 100;
                    const endPos = ((eventData.deathYear + 4500) / 7000) * 100;
                    eventEl.style.left = `${startPos}%`;
                    eventEl.style.width = `${endPos - startPos}%`;
                } else if (eventData.type === 'period') {
                    const startPos = ((eventData.startYear + 4500) / 7000) * 100;
                    const endPos = ((eventData.endYear + 4500) / 7000) * 100;
                    eventEl.style.left = `${startPos}%`;
                    eventEl.style.width = `${endPos - startPos}%`;
                } else { // event type 'event'
                    const position = ((eventData.year + 4500) / 7000) * 100;
                    eventEl.style.left = `${position}%`;
                }
            });
            // Atualiza a lógica de exibição da caixa de descrição de períodos
            document.querySelectorAll('.period-overlay').forEach(periodEl => {
                periodEl.removeEventListener('mouseenter', handlePeriodMouseEnter); // Evita duplicar listeners
                periodEl.removeEventListener('mouseleave', handlePeriodMouseLeave);
                periodEl.addEventListener('mouseenter', handlePeriodMouseEnter);
                periodEl.addEventListener('mouseleave', handlePeriodMouseLeave);
            });
            
            // Reposiciona as anotações
            repositionAnnotations();
            createDateMarkers();
            createVerticalGridLines();
        }
    });

    function handlePeriodMouseEnter() {
        const eventId = parseInt(this.dataset.eventId);
        const eventData = events[eventId];
        if (eventData && periodDescriptionBox && periodTitleBox && periodYearsBox && periodDescBox) {
            periodTitleBox.textContent = eventData.title;
            
            let startYearText = eventData.startYear < 0 ? `${-eventData.startYear} A.C.` : `${eventData.startYear} D.C.`;
            if (eventData.startYear === 0) startYearText = "0";
            let endYearText = eventData.endYear < 0 ? `${-eventData.endYear} A.C.` : `${eventData.endYear} D.C.`;
            if (eventData.endYear === 0) endYearText = "0";
            periodYearsBox.textContent = `${startYearText} até ${endYearText}`;
            
            periodDescBox.textContent = eventData.description || '';
            periodDescriptionBox.style.display = 'block';
            characterDescriptionPopup.style.display = 'none'; // Esconde o popup de personagem/evento
        }
    }

    function handlePeriodMouseLeave() {
        if (periodDescriptionBox) {
            periodDescriptionBox.style.display = 'none';
        }
    }

    // FUNÇÃO CORRIGIDA: Função para ajustar largura da barra de personagem
    function adjustPersonBarWidth(eventEl) {
        const label = eventEl.querySelector('.person-label');
        const lifeSpan = eventEl.querySelector('.life-span');
        
        if (label) {
            // Obter a largura atual baseada no tempo (em porcentagem)
            const currentWidthPercent = parseFloat(eventEl.style.width) || 0;
            
            // Obter a largura do contêiner da timeline
            const timelineWidth = timeline.offsetWidth;
            
            // Obter a largura do texto do label em pixels
            const labelWidthPx = label.offsetWidth;
            
            // Converter a largura do label para porcentagem da timeline
            const labelWidthPercent = (labelWidthPx / timelineWidth) * 100;
            
            // Usar a maior largura entre a baseada no tempo e a necessária para o texto
            const finalWidthPercent = Math.max(currentWidthPercent, labelWidthPercent);
            
            // Aplicar a largura em porcentagem
            eventEl.style.width = `${finalWidthPercent}%`;
            
            // Garantir que o label e o lifeSpan ocupem 100% da largura
            label.style.width = '100%';
            if (lifeSpan) lifeSpan.style.width = '100%';
        }
    }

    function doPeriodsOverlap(start1, end1, start2, end2) {
        const s1 = Math.min(start1, end1);
        const e1 = Math.max(start1, end1);
        const s2 = Math.min(start2, end2);
        const e2 = Math.max(start2, end2);
        return Math.max(s1, s2) < Math.min(e1, e2);
    }


    function createEventElement(eventData) {
        const eventId = events.indexOf(eventData).toString();

        if (eventData.type === 'period') {
            const periodEl = document.createElement('div');
            periodEl.className = 'event period-overlay';
            let colorRgba = applyAlpha(eventData.color, (eventData.opacity || 20) / 100);
            periodEl.style.setProperty('--period-color', colorRgba);
            periodEl.style.backgroundColor = colorRgba;
            const startPos = ((eventData.startYear + 4500) / 7000) * 100;
            const endPos = ((eventData.endYear + 4500) / 7000) * 100;
            const periodWidth = endPos - startPos;
            periodEl.style.left = `${startPos}%`;
            
            // Garantir largura mínima visível para períodos curtos
            if (periodWidth < 0.3) {
                periodEl.style.width = '10px'; // Largura mínima fixa para períodos muito curtos
                periodEl.style.marginLeft = '-5px'; // Centralizar o período
            } else {
                periodEl.style.width = `${periodWidth}%`;
            }
            
            const label = document.createElement('div');
            label.className = 'period-label';
            label.textContent = eventData.title;
            periodEl.appendChild(label);
            // O event-content para period-overlay é gerenciado pela caixa fixa period-description-box
            periodEl.dataset.eventId = eventId;
            periodEl.addEventListener('mouseenter', handlePeriodMouseEnter);
            periodEl.addEventListener('mouseleave', handlePeriodMouseLeave);
            periodEl.addEventListener('contextmenu', (e) => showContextMenu(e, periodEl));
            periodEl.setAttribute('role', 'button');
            periodEl.setAttribute('aria-label', `Período: ${eventData.title}`);
            periodEl.style.zIndex = '1';
            return periodEl;

        } else if (eventData.type === 'person') {
            const eventEl = document.createElement('div');
            eventEl.className = 'event person-event';
            if (eventData.lockedPosition) {
                eventEl.classList.add('locked');
                eventEl.dataset.locked = 'true';
            }
            let colorRgba = applyAlpha(eventData.color, (eventData.opacity || 100) / 100);
            eventEl.style.setProperty('--person-color', colorRgba);

            const startPos = ((eventData.birthYear + 4500) / 7000) * 100;
            const endPos = ((eventData.deathYear + 4500) / 7000) * 100;
            const widthPercentage = endPos - startPos;

            eventEl.style.left = `${startPos}%`;
            eventEl.style.width = `${widthPercentage}%`;

            const row = eventData.personRow;
            if (typeof row !== 'number') {
                eventEl.style.setProperty('--person-row', '0');
                eventEl.style.top = `calc(-24px - (0 * 24px))`;
            } else {
                eventEl.style.setProperty('--person-row', row.toString());
                eventEl.style.top = `calc(-24px - (${row} * 24px))`;
            }

            const lifeSpan = document.createElement('div');
            lifeSpan.className = 'life-span';
            if (eventData.impreciseBirth && eventData.impreciseDeath) lifeSpan.classList.add('imprecise-both');
            else if (eventData.impreciseBirth) lifeSpan.classList.add('imprecise-start');
            else if (eventData.impreciseDeath) lifeSpan.classList.add('imprecise-end');
            lifeSpan.style.background = colorRgba;

            let age;
            if (eventData.birthYear < 0 && eventData.deathYear > 0) {
                age = eventData.deathYear - eventData.birthYear - 2;
            } else {
                age = eventData.deathYear - eventData.birthYear;
            }
            
            const label = document.createElement('div');
            label.className = 'person-label';
            label.textContent = eventData.title;

            const content = document.createElement('div');
            content.className = 'event-content';
            
            let birthYearText = eventData.birthYear < 0 ? `${-eventData.birthYear} A.C.` : `${eventData.birthYear} D.C.`;
            if (eventData.birthYear === 0) birthYearText = "0";
            let deathYearText = eventData.deathYear < 0 ? `${-eventData.deathYear} A.C.` : `${eventData.deathYear} D.C.`;
            if (eventData.deathYear === 0) deathYearText = "0";

            // Adicionamos o ícone do cadeado no tooltip, mas somente se o personagem estiver travado
            const lockIconHtml = eventData.lockedPosition ? '<span class="lock-icon">🔒</span>' : '';
            
            content.innerHTML = `
                <h4>${sanitizeHtml(eventData.title)}</h4>
                <p>${eventData.impreciseBirth ? '(aprox.) ' : ''}${birthYearText} até ${eventData.impreciseDeath ? '(aprox.) ' : ''}${deathYearText}</p>
                <p><strong>Idade: ${age} anos</strong> ${lockIconHtml}</p>
            `;
            eventEl.appendChild(lifeSpan);
            eventEl.appendChild(label);
            eventEl.appendChild(content);
            eventEl.addEventListener('contextmenu', (e) => showContextMenu(e, eventEl));
            eventEl.dataset.eventId = eventId;
            eventEl.setAttribute('role', 'button');
            eventEl.setAttribute('aria-label', `Personagem: ${eventData.title}`);

            eventEl.addEventListener('mouseenter', () => {
                if (characterDescriptionPopup && characterPopupDescriptionText && eventData) {
                    characterPopupDescriptionText.textContent = eventData.description || ''; 
                    characterDescriptionPopup.style.display = 'block';
                    if (periodDescriptionBox) periodDescriptionBox.style.display = 'none'; 
                }
            });

            eventEl.addEventListener('mouseleave', () => {
                if (characterDescriptionPopup) {
                    characterDescriptionPopup.style.display = 'none';
                }
            });

            adjustPersonBarWidth(eventEl);
            return eventEl;

        } else { // Event Type 'event' (flag)
            const position = ((eventData.year + 4500) / 7000) * 100;
            const eventEl = document.createElement('div');
            eventEl.className = 'event event-flag';
            eventEl.style.zIndex = '10';
            eventEl.style.left = `${position}%`;
            let colorRgba = applyAlpha(eventData.color || '#4676E0', (eventData.opacity||100)/100);
            eventEl.style.setProperty('--event-color', colorRgba);

            let maxPersonRowForFlagHeight = -1;
            window.events.forEach(p => {
                if (p.type === 'person' && typeof p.personRow === 'number') {
                    if (p.personRow > maxPersonRowForFlagHeight) {
                        maxPersonRowForFlagHeight = p.personRow;
                    }
                }
            });

            const baseHeight = 200 + ((maxPersonRowForFlagHeight + 1) * 24) + 10;
            const line = document.createElement('div');
            line.className = 'event-flag-line';
            line.style.height = `${baseHeight}px`;
            
            let yearText = eventData.year < 0 ? `${-eventData.year} A.C.` : `${eventData.year} D.C.`;
            if (eventData.year === 0) yearText = "0";
            line.dataset.year = yearText;

            const content = document.createElement('div');
            content.className = 'event-content';
            content.innerHTML = `
                <h3>${yearText}</h3>
                <h4>${sanitizeHtml(eventData.title)}</h4>
                `;
            eventEl.appendChild(line);
            eventEl.appendChild(content); 
            eventEl.setAttribute('role', 'button');
            eventEl.setAttribute('aria-label', `Evento: ${eventData.title} em ${yearText}`);

            eventEl.addEventListener('mouseenter', () => {
                if (characterDescriptionPopup && characterPopupDescriptionText && eventData) {
                    characterPopupDescriptionText.textContent = eventData.description || ''; 
                    characterDescriptionPopup.style.display = 'block';
                     if (periodDescriptionBox) periodDescriptionBox.style.display = 'none';
                }
            });

            eventEl.addEventListener('mouseleave', () => {
                if (characterDescriptionPopup) {
                    characterDescriptionPopup.style.display = 'none';
                }
            });

            eventEl.addEventListener('contextmenu', (e) => showContextMenu(e, eventEl));
            eventEl.dataset.eventId = eventId;
            return eventEl;
        }
    }

    function applyAlpha(hexOrRgb, alpha) {
        alpha = Math.max(0, Math.min(1, Math.round(alpha * 100) / 100));
        if (hexOrRgb.startsWith('#')) {
            let hex = hexOrRgb.replace('#', '');
            if (hex.length === 3) hex = hex.split('').map(x => x + x).join('');
            const num = parseInt(hex, 16);
            const r = (num >> 16) & 255;
            const g = (num >> 8) & 255;
            const b = num & 255;
            return `rgba(${r},${g},${b},${alpha})`;
        } else if (hexOrRgb.startsWith('rgb')) {
            let m = hexOrRgb.match(/[\d.]+/g);
            if (m && m.length >= 3) return `rgba(${m[0]},${m[1]},${m[2]},${alpha})`;
        }
        return hexOrRgb;
    }

    function setupOpacityInputs() {
        const eventOpacity = document.getElementById('event-opacity');
        const eventOpacityValue = document.getElementById('event-opacity-value');
        if (eventOpacity && eventOpacityValue) {
            eventOpacityValue.textContent = eventOpacity.value + '%';
            eventOpacity.addEventListener('input', () => eventOpacityValue.textContent = eventOpacity.value + '%' );
        }
        const personOpacity = document.getElementById('person-opacity');
        const personOpacityValue = document.getElementById('person-opacity-value');
        if (personOpacity && personOpacityValue) {
            personOpacityValue.textContent = personOpacity.value + '%';
            personOpacity.addEventListener('input', () => personOpacityValue.textContent = personOpacity.value + '%' );
        }
    }

    function setPersonForm() {
        document.querySelector('.event-fields').style.display = 'none';
        document.querySelector('.person-fields').innerHTML = `
            <label>Personagem - Período do Personagem</label>
            <div class="form-row">
              <div class="form-group autocomplete-container">
                <label for="birth-year">Data Inicial:</label>
                <input type="number" id="birth-year" required class="autocomplete-input">
                <div class="autocomplete-suggestions"></div>
              </div>
              <div style="display: flex; align-items: center; padding: 0 10px;">
                <span>até</span>
              </div>
              <div class="form-group autocomplete-container">
                <label for="death-year">Data Final:</label>
                <input type="number" id="death-year" required class="autocomplete-input">
                <div class="autocomplete-suggestions"></div>
              </div>
            </div>
            <div class="form-row checkbox-container">
              <div class="checkbox-wrapper">
                <input type="checkbox" id="imprecise-birth">
                <label for="imprecise-birth">Data inicial aproximada</label>
              </div>
              <div class="checkbox-wrapper">
                <input type="checkbox" id="imprecise-death">
                <label for="imprecise-death">Data final aproximada</label>
              </div>
            </div>
            <label for="person-color">Cor do Personagem:</label>
            <input type="color" id="person-color" value="#4676E0">
            <label for="person-opacity">Transparência:</label>
            <input type="range" id="person-opacity" min="0" max="100" value="100" style="width: 120px;">
            <span id="person-opacity-value">100%</span>
        `;
        document.querySelector('.person-fields').style.display = 'block';
        setupOpacityInputs();
        setupAutoComplete();
    }

    function setEventForm() {
        document.querySelector('.event-fields').innerHTML = `
            <label for="event-year">Ano (use - para A.C.):</label>
            <input type="number" id="event-year" required class="autocomplete-input">
            <div class="autocomplete-suggestions"></div>
            <label for="event-color">Cor do Evento:</label>
            <input type="color" id="event-color" value="#4676E0">
            <label for="event-opacity">Transparência:</label>
            <input type="range" id="event-opacity" min="0" max="100" value="100" style="width: 120px;">
            <span id="event-opacity-value">100%</span>
        `;
        document.querySelector('.event-fields').style.display = 'block';
        document.querySelector('.person-fields').style.display = 'none';
        setupOpacityInputs();
        setupAutoComplete();
    }

    function setPeriodForm() {
        document.querySelector('.event-fields').innerHTML = `
            <div class="form-group">
              <label>Período:</label>
              <div class="form-row">
                  <div class="form-group autocomplete-container">
                      <label for="period-start">Data Inicial:</label>
                      <input type="number" id="period-start" required class="autocomplete-input">
                      <div class="autocomplete-suggestions"></div>
                  </div>
                  <div style="display: flex; align-items: center; padding: 0 10px;">
                      <span>até</span>
                  </div>
                  <div class="form-group autocomplete-container">
                      <label for="period-end">Data Final:</label>
                      <input type="number" id="period-end" required class="autocomplete-input">
                      <div class="autocomplete-suggestions"></div>
                  </div>
              </div>
              <small style="color: var(--text-color);">Obs.: Para A.C. usar sinal -</small>
            </div>
            <div class="form-group">
              <label for="event-color">Cor do Período:</label>
              <input type="color" id="event-color" value="#4676E0">
              <label for="event-opacity">Transparência:</label>
              <input type="range" id="event-opacity" min="0" max="100" value="20" style="width: 120px;">
              <span id="event-opacity-value">20%</span>
            </div>
        `;
        document.querySelector('.event-fields').style.display = 'block';
        document.querySelector('.person-fields').style.display = 'none';
        setupOpacityInputs();
        setupAutoComplete();
    }

    // Configuração de auto completar para campos de data
    function setupAutoComplete() {
        const autocompleteInputs = document.querySelectorAll('.autocomplete-input');
        
        autocompleteInputs.forEach(input => {
            const suggestionsContainer = input.parentElement.querySelector('.autocomplete-suggestions');
            
            if (!suggestionsContainer) return;
            
            // Cria uma lista de anos já usados na linha do tempo
            let yearsUsed = [];
            
            events.forEach(event => {
                if (event.type === 'event') {
                    yearsUsed.push(event.year);
                } else if (event.type === 'person') {
                    yearsUsed.push(event.birthYear, event.deathYear);
                } else if (event.type === 'period') {
                    yearsUsed.push(event.startYear, event.endYear);
                }
            });
            
            // Remove duplicatas e ordena
            yearsUsed = [...new Set(yearsUsed)].sort((a, b) => a - b);
            
            // Adiciona alguns anos comuns para A.C. e D.C. caso não existam
            const commonYearsBC = [-3000, -2000, -1000, -500, -100, -50];
            const commonYearsAD = [0, 1, 500, 1000, 1500, 1800, 1900, 2000];
            
            yearsUsed = [...new Set([...yearsUsed, ...commonYearsBC, ...commonYearsAD])].sort((a, b) => a - b);
            
            // Função para mostrar sugestões baseadas no valor atual
            function showSuggestions() {
                const value = input.value.trim();
                
                // Se o campo estiver vazio, mostra alguns valores comuns
                let suggestions = value ? 
                    yearsUsed.filter(year => year.toString().includes(value)) : 
                    [-3000, -2000, -1000, -500, -100, 0, 1, 500, 1000, 1500, 1800, 1900, 2000];
                
                // Limitando a 5 sugestões
                suggestions = suggestions.slice(0, 5);
                
                if (suggestions.length > 0) {
                    let html = '';
                    suggestions.forEach(year => {
                        html += `<div class="autocomplete-suggestion" data-value="${year}">${formatYear(year)}</div>`;
                    });
                    
                    suggestionsContainer.innerHTML = html;
                    suggestionsContainer.classList.add('active');
                    
                    // Adiciona eventos de clique nas sugestões
                    const suggestionElements = suggestionsContainer.querySelectorAll('.autocomplete-suggestion');
                    suggestionElements.forEach(element => {
                        element.addEventListener('click', () => {
                            input.value = element.dataset.value;
                            suggestionsContainer.classList.remove('active');
                        });
                    });
                } else {
                    suggestionsContainer.classList.remove('active');
                }
            }
            
            // Eventos para mostrar e esconder sugestões
            input.addEventListener('focus', showSuggestions);
            input.addEventListener('input', showSuggestions);
            
            // Fechar sugestões ao clicar fora
            document.addEventListener('click', (e) => {
                if (!input.contains(e.target) && !suggestionsContainer.contains(e.target)) {
                    suggestionsContainer.classList.remove('active');
                }
            });
            
            // Navegação pelo teclado
            input.addEventListener('keydown', (e) => {
                const suggestions = suggestionsContainer.querySelectorAll('.autocomplete-suggestion');
                if (!suggestions.length) return;
                
                // Encontrar seleção atual
                let selected = suggestionsContainer.querySelector('.selected');
                let index = Array.from(suggestions).indexOf(selected);
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (selected) {
                        selected.classList.remove('selected');
                        index = (index + 1) % suggestions.length;
                    } else {
                        index = 0;
                    }
                    suggestions[index].classList.add('selected');
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (selected) {
                        selected.classList.remove('selected');
                        index = (index - 1 + suggestions.length) % suggestions.length;
                    } else {
                        index = suggestions.length - 1;
                    }
                    suggestions[index].classList.add('selected');
                } else if (e.key === 'Enter' && selected) {
                    e.preventDefault();
                    input.value = selected.dataset.value;
                    suggestionsContainer.classList.remove('active');
                } else if (e.key === 'Escape') {
                    suggestionsContainer.classList.remove('active');
                }
            });
        });
    }

    setupOpacityInputs();

    // Melhorar o manipulador de salvar com validação
    function defaultSaveHandler(e) {
        e.preventDefault();
        const isPersonForm = document.querySelector('.person-fields').style.display === 'block' && document.getElementById('birth-year');
        const isPeriodForm = document.getElementById('period-start') !== null && document.querySelector('.event-fields').style.display === 'block' && !document.getElementById('event-year');
        
        // Determina o tipo de formulário
        let type = 'event';
        if (isPersonForm) type = 'person';
        if (isPeriodForm) type = 'period';
        
        // Valida o formulário
        if (!validateForm(type)) return;
        
        if (isPersonForm) {
            const birthYear = parseInt(document.getElementById('birth-year').value);
            const deathYear = parseInt(document.getElementById('death-year').value);
            const title = document.getElementById('event-title').value;
            
            tempNewPersonData = {
                type: 'person', 
                birthYear, 
                deathYear, 
                title,
                description: document.getElementById('event-description').value || '',
                color: document.getElementById('person-color').value,
                impreciseBirth: document.getElementById('imprecise-birth').checked,
                impreciseDeath: document.getElementById('imprecise-death').checked,
                opacity: document.getElementById('person-opacity') ? parseInt(document.getElementById('person-opacity').value) : 100
            };
            
            // Fechar o formulário
            eventForm.classList.remove('active');
            
            // Mostrar diálogo de posicionamento
            positionDialog.style.display = 'block';
            
        } else if (isPeriodForm) {
            const startYear = parseInt(document.getElementById('period-start').value);
            const endYear = parseInt(document.getElementById('period-end').value);
            const title = document.getElementById('event-title').value;
            
            const newEventData = {
                type: 'period', 
                startYear, 
                endYear, 
                title,
                description: document.getElementById('event-description').value || '',
                color: document.getElementById('event-color').value,
                opacity: document.getElementById('event-opacity') ? parseInt(document.getElementById('event-opacity').value) : 20
            };
            
            events.push(newEventData);
            window.events = events;
            renderEvents();
            closeForm();
            showToast("Período adicionado com sucesso");
            
            // Salva automaticamente após adicionar um novo item
            localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: currentZoom }));
        } else {
            const year = parseInt(document.getElementById('event-year').value);
            const title = document.getElementById('event-title').value;
            
            const newEventData = {
                type: 'event', 
                year, 
                title,
                description: document.getElementById('event-description').value || '',
                color: document.getElementById('event-color').value,
                opacity: document.getElementById('event-opacity') ? parseInt(document.getElementById('event-opacity').value) : 100
            };
            
            events.push(newEventData);
            window.events = events;
            renderEvents();
            closeForm();
            showToast("Evento adicionado com sucesso");
            
            // Salva automaticamente após adicionar um novo item
            localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: currentZoom }));
        }
    }

    function closeForm() {
        eventForm.classList.remove('active');
        annotationForm.classList.remove('active');
        overlay.classList.remove('active');
        eventForm.reset();
        annotationForm.reset();
        document.getElementById('form-error').style.display = 'none';
        document.getElementById('annotation-form-error').style.display = 'none';
        
        if (temporaryAnnotationPin) {
            temporaryAnnotationPin.remove();
            temporaryAnnotationPin = null;
        }
        
        saveBtn.onclick = defaultSaveHandler;
    }

    cancelBtn.addEventListener('click', closeForm);
    overlay.addEventListener('click', (e) => {
        // Fechamos o formulário ao clicar no overlay, mas não fechamos os modals
        if (eventForm.classList.contains('active') || annotationForm.classList.contains('active')) {
            closeForm();
        }
        // Fechamos o context menu
        hideContextMenu();
        // Não fechamos nenhum modal se algum deles estiver ativo
        if ([statsModal, keyboardModal, tutorialModal, templatesModal, annotationsModal].some(modal => modal.classList.contains('active'))) {
            return;
        }
    });
    document.querySelector('.save-btn').addEventListener('click', saveToFile);

    function saveToFile() {
        // Prepara os dados para salvar incluindo eventos e anotações
        const dataToSave = {
            events: events,
            zoom: currentZoom,
            annotations: annotations
        };
        
        const data = JSON.stringify(dataToSave);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'timelineData.json';
        a.click();
        URL.revokeObjectURL(url);
        showToast("Timeline salva com sucesso");
    }

    document.querySelector('.pdf-btn').addEventListener('click', exportToPDF);

    function exportToPDF() {
        // Cria um container especial para o PDF com design melhorado
        const pdfContainer = document.createElement('div');
        pdfContainer.className = 'pdf-container';
        
        // Cabeçalho com título
        const header = document.createElement('div');
        header.className = 'pdf-header';
        header.innerHTML = `
            <h1 class="pdf-title">Linha do Tempo Histórica</h1>
            <div class="pdf-subtitle">Gerado em ${new Date().toLocaleDateString()} às ${new Date().toLocaleTimeString()}</div>
        `;
        pdfContainer.appendChild(header);
        
        // Adiciona o clone da linha do tempo
        const timelineClone = document.createElement('div');
        timelineClone.className = 'pdf-timeline';
        
        // Gera um sumário dos eventos
        const summary = document.createElement('div');
        summary.style.marginBottom = '30px';
        
        let summaryContent = '<h2 style="color: #1565C0; margin-bottom: 15px;">Sumário dos Eventos</h2>';
        summaryContent += '<div style="columns: 2; column-gap: 20px;">';
        
        // Organiza eventos cronologicamente
        const eventsSorted = [...events].sort((a, b) => {
            const timeA = a.type === 'event' ? a.year : a.type === 'person' ? a.birthYear : a.startYear;
            const timeB = b.type === 'event' ? b.year : b.type === 'person' ? b.birthYear : b.startYear;
            return timeA - timeB;
        });
        
        eventsSorted.forEach(event => {
            let timeText = '';
            let typeIcon = '';
            
            if (event.type === 'event') {
                timeText = formatYear(event.year);
                typeIcon = '<svg viewBox="0 0 24 24" width="16" height="16" style="margin-right: 5px; vertical-align: middle;"><path fill="currentColor" d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"></path></svg>';
            } else if (event.type === 'person') {
                timeText = `${formatYear(event.birthYear)} - ${formatYear(event.deathYear)}`;
                typeIcon = '<svg viewBox="0 0 24 24" width="16" height="16" style="margin-right: 5px; vertical-align: middle;"><path fill="currentColor" d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0-6c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm0 7c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z"></path></svg>';
            } else if (event.type === 'period') {
                timeText = `${formatYear(event.startYear)} - ${formatYear(event.endYear)}`;
                typeIcon = '<svg viewBox="0 0 24 24" width="16" height="16" style="margin-right: 5px; vertical-align: middle;"><path fill="currentColor" d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V9h14v10zm0-12H5V5h14v2zM7 11h5v5H7z"></path></svg>';
            }
            
            summaryContent += `
                <div style="margin-bottom: 10px; break-inside: avoid;">
                    <div style="font-weight: bold;">${typeIcon} ${sanitizeHtml(event.title)}</div>
                    <div style="font-size: 12px; color: #555;">${timeText}</div>
                </div>
            `;
        });
        
        summaryContent += '</div>';
        summary.innerHTML = summaryContent;
        pdfContainer.appendChild(summary);
        
        // Adiciona a timeline atual ao container
        const timelineActual = timelineContainer.cloneNode(true);
        timelineActual.style.height = '500px';
        timelineActual.style.position = 'relative';
        timelineActual.style.overflow = 'hidden';
        timelineActual.style.marginBottom = '30px';
        timelineActual.style.border = '1px solid #ddd';
        timelineActual.style.borderRadius = '8px';
        
        timelineClone.appendChild(timelineActual);
        pdfContainer.appendChild(timelineClone);
        
        // Adiciona metadados e rodapé
        const meta = document.createElement('div');
        meta.className = 'pdf-meta';
        meta.innerHTML = `
            <div>Total de eventos: ${events.filter(e => e.type === 'event').length}</div>
            <div>Total de personagens: ${events.filter(e => e.type === 'person').length}</div>
            <div>Total de períodos: ${events.filter(e => e.type === 'period').length}</div>
        `;
        pdfContainer.appendChild(meta);
        
        const watermark = document.createElement('div');
        watermark.className = 'pdf-watermark';
        watermark.textContent = 'Criado com Linha do Tempo Histórica';
        pdfContainer.appendChild(watermark);
        
        // Configura opções do PDF
        const opt = {
            margin: [10, 10, 10, 10],
            filename: 'linha_do_tempo_historica.pdf',
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: { scale: 2 },
            jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' }
        };
        
        showToast("Gerando PDF...");
        html2pdf().set(opt).from(pdfContainer).save().then(() => {
            showToast("PDF gerado com sucesso");
        }).catch(err => {
            console.error("Erro ao gerar PDF:", err);
            showToast("Erro ao gerar PDF", "error");
        });
    }

    function showContextMenu(e, eventEl) {
        e.preventDefault();
        e.stopPropagation();
        selectedEventElement = eventEl;
        const isInsideForm = eventForm.contains(e.target);
        const isActiveDropdown = document.querySelector('.action-buttons.active');
        const isInsideDropdown = isActiveDropdown && isActiveDropdown.querySelector('.dropdown-content').contains(e.target);
        if (isInsideForm || isInsideDropdown) {
            hideContextMenu();
            return;
        }
        
        // Verifica se é um personagem para mostrar a opção de travar/destravar
        const eventId = parseInt(eventEl.dataset.eventId);
        const eventData = events[eventId];
        
        if (eventData && eventData.type === 'person') {
            contextToggleLock.style.display = 'block';
            contextToggleLock.textContent = eventData.lockedPosition ? "Destravar posição" : "Travar posição";
        } else {
            contextToggleLock.style.display = 'none';
        }
        
        contextMenu.style.left = e.pageX + 'px';
        contextMenu.style.top = e.pageY + 'px';
        contextMenu.classList.add('active');
    }

    function hideContextMenu() {
        contextMenu.classList.remove('active');
        selectedEventElement = null;
    }
    
    // Adicionar manipulador para opção de travar/destravar
    contextToggleLock.addEventListener('click', function() {
        if (!selectedEventElement) return;
        
        const eventId = parseInt(selectedEventElement.dataset.eventId);
        const eventData = events[eventId];
        
        if (eventData && eventData.type === 'person') {
            // Inverte o estado de travamento
            eventData.lockedPosition = !eventData.lockedPosition;
            
            // Atualiza a interface
            if (eventData.lockedPosition) {
                selectedEventElement.classList.add('locked');
                selectedEventElement.dataset.locked = 'true';
            } else {
                selectedEventElement.classList.remove('locked');
                delete selectedEventElement.dataset.locked;
            }
            
            // Atualiza o conteúdo do evento para refletir a mudança
            const content = selectedEventElement.querySelector('.event-content');
            if (content) {
                let birthYearText = eventData.birthYear < 0 ? `${-eventData.birthYear} A.C.` : `${eventData.birthYear} D.C.`;
                if (eventData.birthYear === 0) birthYearText = "0";
                let deathYearText = eventData.deathYear < 0 ? `${-eventData.deathYear} A.C.` : `${eventData.deathYear} D.C.`;
                if (eventData.deathYear === 0) deathYearText = "0";
                
                let age;
                if (eventData.birthYear < 0 && eventData.deathYear > 0) {
                    age = eventData.deathYear - eventData.birthYear - 2;
                } else {
                    age = eventData.deathYear - eventData.birthYear;
                }
                
                // Adicionar ou remover o ícone de cadeado baseado no estado de travamento
                const lockIconHtml = eventData.lockedPosition ? '<span class="lock-icon">🔒</span>' : '';
                
                content.innerHTML = `
                    <h4>${sanitizeHtml(eventData.title)}</h4>
                    <p>${eventData.impreciseBirth ? '(aprox.) ' : ''}${birthYearText} até ${eventData.impreciseDeath ? '(aprox.) ' : ''}${deathYearText}</p>
                    <p><strong>Idade: ${age} anos</strong> ${lockIconHtml}</p>
                `;
            }
            
            // Salva as alterações
            localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: currentZoom }));
            
            showToast(eventData.lockedPosition ? 
                `Personagem "${eventData.title}" travado` : 
                `Personagem "${eventData.title}" destravado`);
        }
        
        hideContextMenu();
    });

    document.querySelector('.context-menu-item.edit').addEventListener('click', function() {
        if (!selectedEventElement) return;
        const eventIndex = parseInt(selectedEventElement.dataset.eventId);
        const eventData = events[eventIndex];
        if (!eventData) return;

        if (eventData.type === 'period') {
            setPeriodForm();
            document.getElementById('period-start').value = eventData.startYear;
            document.getElementById('period-end').value = eventData.endYear;
            document.getElementById('event-color').value = eventData.color || '#4676E0';
            document.getElementById('event-opacity').value = eventData.opacity !== undefined ? eventData.opacity : 20;
            if(document.getElementById('event-opacity-value')) document.getElementById('event-opacity-value').textContent = (eventData.opacity !== undefined ? eventData.opacity : 20) + '%';
        } else if (eventData.type === 'person') {
            setPersonForm();
            document.getElementById('birth-year').value = eventData.birthYear;
            document.getElementById('death-year').value = eventData.deathYear;
            document.getElementById('person-color').value = eventData.color || '#4676E0';
            document.getElementById('imprecise-birth').checked = eventData.impreciseBirth || false;
            document.getElementById('imprecise-death').checked = eventData.impreciseDeath || false;
            if(document.getElementById('person-opacity')) {
                document.getElementById('person-opacity').value = eventData.opacity !== undefined ? eventData.opacity : 100;
                if(document.getElementById('person-opacity-value')) document.getElementById('person-opacity-value').textContent = (eventData.opacity !== undefined ? eventData.opacity : 100) + '%';
            }
        } else { // Evento tipo 'event' (bandeira)
            setEventForm();
            document.getElementById('event-year').value = eventData.year;
            document.getElementById('event-color').value = eventData.color || '#4676E0';
            document.getElementById('event-opacity').value = eventData.opacity !== undefined ? eventData.opacity : 100;
            if(document.getElementById('event-opacity-value')) document.getElementById('event-opacity-value').textContent = (eventData.opacity !== undefined ? eventData.opacity : 100) + '%';
        }
        document.getElementById('event-title').value = eventData.title;
        document.getElementById('event-description').value = eventData.description || '';
        eventForm.classList.add('active');
        overlay.classList.add('active');
        document.getElementById('form-error').style.display = 'none';

        saveBtn.onclick = function(eClick) {
            eClick.preventDefault();
            
            // Validação aprimorada
            if (!validateForm(eventData.type)) return;
            
            let updatedEventData = { ...eventData };

            if (eventData.type === 'person') {
                const newBirthYear = parseInt(document.getElementById('birth-year').value);
                const newDeathYear = parseInt(document.getElementById('death-year').value);
                
                updatedEventData = { ...updatedEventData,
                    birthYear: newBirthYear,
                    deathYear: newDeathYear,
                    title: document.getElementById('event-title').value,
                    description: document.getElementById('event-description').value,
                    color: document.getElementById('person-color').value,
                    impreciseBirth: document.getElementById('imprecise-birth').checked,
                    impreciseDeath: document.getElementById('imprecise-death').checked,
                    opacity: document.getElementById('person-opacity') ? parseInt(document.getElementById('person-opacity').value) : 100
                };
            } else if (eventData.type === 'period') {
                 const newStartYear = parseInt(document.getElementById('period-start').value);
                 const newEndYear = parseInt(document.getElementById('period-end').value);
                
                updatedEventData = { ...updatedEventData,
                    startYear: newStartYear,
                    endYear: newEndYear,
                    title: document.getElementById('event-title').value,
                    description: document.getElementById('event-description').value,
                    color: document.getElementById('event-color').value,
                    opacity: document.getElementById('event-opacity') ? parseInt(document.getElementById('event-opacity').value) : 20
                };
            } else {
                updatedEventData = { ...updatedEventData,
                    year: parseInt(document.getElementById('event-year').value),
                    title: document.getElementById('event-title').value,
                    description: document.getElementById('event-description').value,
                    color: document.getElementById('event-color').value,
                    opacity: document.getElementById('event-opacity') ? parseInt(document.getElementById('event-opacity').value) : 100
                };
            }
            events[eventIndex] = updatedEventData;
            window.events = events;
            renderEvents();
            closeForm();
            hideContextMenu();
            showToast("Evento atualizado com sucesso");
            
            // Salva automaticamente após editar
            localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: currentZoom }));
        };
    });
    
    document.querySelector('.context-menu-item.annotate').addEventListener('click', function() {
        if (!selectedEventElement) return;
        
        // Posição do evento na timeline para a anotação
        const rect = selectedEventElement.getBoundingClientRect();
        const timelineRect = timeline.getBoundingClientRect();
        
        // Calcule a posição relativa
        const x = ((rect.left + rect.width/2 - timelineRect.left) / timelineRect.width) * 100;
        const y = ((rect.top - timelineRect.top) / timelineRect.height) * 100;
        
        // Cria um pino temporário
        temporaryAnnotationPin = document.createElement('div');
        temporaryAnnotationPin.className = 'annotation-pin';
        temporaryAnnotationPin.textContent = '+';
        temporaryAnnotationPin.style.left = `${x}%`;
        temporaryAnnotationPin.style.top = `${y}%`;
        temporaryAnnotationPin.dataset.x = x;
        temporaryAnnotationPin.dataset.y = y;
        temporaryAnnotationPin.dataset.eventId = selectedEventElement.dataset.eventId;
        
        timeline.appendChild(temporaryAnnotationPin);
        
        // Abre o formulário de anotação
        annotationForm.classList.add('active');
        overlay.classList.add('active');
        
        hideContextMenu();
    });

    document.querySelector('.context-menu-item.delete').addEventListener('click', () => {
        if (!selectedEventElement) return;
        const eventIndex = parseInt(selectedEventElement.dataset.eventId);
        if (confirm('Tem certeza que deseja apagar este item?')) {
            events.splice(eventIndex, 1);
            window.events = events;
            renderEvents();
            hideContextMenu();
            showToast("Evento removido com sucesso");
            
            // Salva automaticamente após remover
            localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: currentZoom }));
        } else {
            hideContextMenu();
        }
    });

    document.querySelector('.clear-btn').addEventListener('click', () => {
        if (confirm('Tem certeza que deseja limpar todos os dados e carregar um novo arquivo? Esta ação não pode ser desfeita.')) {
            window.events = events = [];
            localStorage.removeItem('timelineData');
            renderEvents();
            fileInput.value = null;
            fileInput.click();
        }
    });

    document.addEventListener('click', (e) => {
      if (contextMenu && !contextMenu.contains(e.target) && selectedEventElement && !eventForm.contains(e.target)) {
          hideContextMenu();
      }
      const actionButtonsContainer = document.querySelector('.action-buttons');
      if (actionButtonsContainer && !actionButtonsContainer.contains(e.target) && actionButtonsContainer.classList.contains('active')) {
          actionButtonsContainer.classList.remove('active');
      }
    });
    if(contextMenu) contextMenu.addEventListener('click', (e) => e.stopPropagation());

    menuBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        document.querySelector('.action-buttons').classList.toggle('active');
    });

    addPersonBtn.addEventListener('click', () => {
        setPersonForm(); eventForm.reset();
        document.getElementById('event-title').value = '';
        document.getElementById('event-description').value = '';
        eventForm.classList.add('active'); overlay.classList.add('active');
        saveBtn.onclick = defaultSaveHandler;
        document.getElementById('form-error').style.display = 'none';
    });
    addEventBtn.addEventListener('click', () => {
        setEventForm(); eventForm.reset();
        document.getElementById('event-title').value = '';
        document.getElementById('event-description').value = '';
        eventForm.classList.add('active'); overlay.classList.add('active');
        saveBtn.onclick = defaultSaveHandler;
        document.getElementById('form-error').style.display = 'none';
    });
    addPeriodBtn.addEventListener('click', () => {
        setPeriodForm(); eventForm.reset();
        document.getElementById('event-title').value = '';
        document.getElementById('event-description').value = '';
        eventForm.classList.add('active'); overlay.classList.add('active');
        saveBtn.onclick = defaultSaveHandler;
        document.getElementById('form-error').style.display = 'none';
    });

    renderEvents();

    function centerTimelineOnLoad() {
        const baseWidth = 100;
        timeline.style.width = `${baseWidth * Math.pow(2, currentZoom/25)}%`;
        const centerYearPositionRatio = 4500 / 7000;
        const timelinePhysicalWidth = timeline.offsetWidth;
        const centerScrollPosition = (timelinePhysicalWidth * centerYearPositionRatio) - (timelineContainer.offsetWidth / 2);
        timelineContainer.scrollLeft = centerScrollPosition > 0 ? centerScrollPosition : 0;
    }
    setTimeout(centerTimelineOnLoad, 150);

    function createDateMarkers() {
        const dateMarkersContainer = timeline.querySelector('.date-markers');
        if (!dateMarkersContainer) return;
        dateMarkersContainer.innerHTML = '';
        const absoluteMinYear = -4500;
        const absoluteMaxYear = 2500;
        const totalRange = absoluteMaxYear - absoluteMinYear;
        let step, minorStep;
        if (currentZoom <= 15) { step = 1000; minorStep = 200; }
        else if (currentZoom <= 30) { step = 500; minorStep = 100; }
        else if (currentZoom <= 50) { step = 250; minorStep = 50; }
        else if (currentZoom <= 75) { step = 100; minorStep = 20; }
        else { step = 50; minorStep = 10; }
        
        // Usar DocumentFragment para melhor performance
        const fragment = document.createDocumentFragment();
        
        for(let year = absoluteMinYear; year <= absoluteMaxYear; year += step) {
            const marker = document.createElement('div');
            marker.className = 'date-marker';
            const position = ((year - absoluteMinYear) / totalRange) * 100;
            marker.style.left = `${position}%`;
            const span = document.createElement('span');
            span.style.fontSize = '12px';
            
            let yearText = year < 0 ? `${-year} A.C.` : (year > 0 ? `${year} D.C.` : '0');
            span.textContent = yearText;
            
            marker.appendChild(span);
            fragment.appendChild(marker);
            
            if (year < absoluteMaxYear) {
                for(let mYear = year + minorStep; mYear < year + step && mYear <= absoluteMaxYear; mYear += minorStep) {
                    if (mYear === 0 && year !== 0 && (year + step) !== 0) continue;
                    const minorTick = document.createElement('div');
                    minorTick.className = 'minor-tick';
                    const minorPosition = ((mYear - absoluteMinYear) / totalRange) * 100;
                    minorTick.style.left = `${minorPosition}%`;
                    fragment.appendChild(minorTick);
                }
            }
        }
        
        dateMarkersContainer.appendChild(fragment);
        
        // Criar linhas de grade vertical após criar marcadores
        createVerticalGridLines();
    }
    
    function repositionAnnotations() {
        document.querySelectorAll('.annotation-pin').forEach(pin => {
            // Se o pin tem posição em porcentagem, mantém
            if (pin.dataset.x && pin.dataset.y) {
                pin.style.left = `${pin.dataset.x}%`;
                pin.style.top = `${pin.dataset.y}%`;
            }
        });
    }

    function renderEvents(skipReposition = false) {
        if (!skipReposition) {
            // Remove a propriedade personRow apenas para personagens não travados
            events.forEach(event => {
                if (event.type === 'person' && !event.lockedPosition) {
                    delete event.personRow;
                }
            });

            // Filtra apenas os personagens que não estão travados para calcular as posições
            const personEventsToAssignRows = events.filter(e => e.type === 'person' && !e.lockedPosition);

            personEventsToAssignRows.sort((a, b) => {
                if (a.birthYear !== b.birthYear) {
                    return b.birthYear - a.birthYear;
                }
                const indexA = window.events.indexOf(a);
                const indexB = window.events.indexOf(b);
                return indexA - indexB;
            });

            const occupiedRowsMap = [];
            
            // Primeiro, considere os personagens com posição travada
            events.filter(e => e.type === 'person' && e.lockedPosition).forEach(lockedPerson => {
                const row = lockedPerson.personRow !== undefined ? lockedPerson.personRow : 0;
                if (!occupiedRowsMap[row]) {
                    occupiedRowsMap[row] = [];
                }
                occupiedRowsMap[row].push(lockedPerson);
            });

            // Depois, atribua linhas para personagens não travados
            personEventsToAssignRows.forEach(currentPerson => {
                let assignedRow = -1;
                for (let r = 0; ; r++) {
                    if (!occupiedRowsMap[r]) {
                        occupiedRowsMap[r] = [];
                    }

                    let overlapsOnThisRow = false;
                    for (const pOnRow of occupiedRowsMap[r]) {
                        if (doPeriodsOverlap(currentPerson.birthYear, currentPerson.deathYear, pOnRow.birthYear, pOnRow.deathYear)) {
                            overlapsOnThisRow = true;
                            break;
                        }
                    }

                    if (!overlapsOnThisRow) {
                        currentPerson.personRow = r;
                        occupiedRowsMap[r].push(currentPerson);
                        assignedRow = r;
                        break;
                    }
                }
            });
        }

        timeline.innerHTML = '<div class="background-grid" id="background-grid"></div><div class="timeline-line"></div><div class="center-marker-line" style="left: calc(((4499) / 7000) * 100%);"></div><div class="date-markers"></div>';

        // Usar DocumentFragment para otimizar a renderização
        const fragment = document.createDocumentFragment();

        // Renderiza períodos primeiro (camada inferior)
        events.filter(e => e.type === 'period').forEach(eventData => {
            fragment.appendChild(createEventElement(eventData));
        });
        
        // Depois renderiza personagens
        events.filter(e => e.type === 'person').forEach(eventData => {
            fragment.appendChild(createEventElement(eventData));
        });
        
        // Por último, renderiza eventos (camada superior)
        events.filter(e => e.type === 'event').forEach(eventData => {
            fragment.appendChild(createEventElement(eventData));
        });

        timeline.appendChild(fragment);

        document.querySelectorAll('.period-overlay').forEach(periodEl => {
            periodEl.removeEventListener('mouseenter', handlePeriodMouseEnter); 
            periodEl.removeEventListener('mouseleave', handlePeriodMouseLeave);
            periodEl.addEventListener('mouseenter', handlePeriodMouseEnter);
            periodEl.addEventListener('mouseleave', handlePeriodMouseLeave);
        });

        createDateMarkers();
        document.querySelectorAll('.person-event').forEach(eventEl => adjustPersonBarWidth(eventEl));
        localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: currentZoom }));
        enableVerticalDragging();
        
        // Renderiza as anotações após renderizar os eventos
        renderAnnotations();
    }


    zoomSlider.addEventListener('input', function(e) {
        window.currentZoom = currentZoom = parseInt(e.target.value);
        zoomLabel.textContent = currentZoom + '%';
        const actualZoom = Math.pow(2, currentZoom/25);
        const baseWidth = 100;
        timeline.style.width = `${baseWidth * actualZoom}%`;
        
        // Implementação melhorada para reduzir sobreposição quando diminui o zoom
        const eventElements = document.querySelectorAll('.event');
        const minEventWidth = 40; // Largura mínima em pixels para evitar sobreposição
        
        // Verifica a largura física da timeline para calcular o fator de escala
        const timelineWidth = timeline.offsetWidth;
        const minWidthInPercent = (minEventWidth / timelineWidth) * 100;
        
        eventElements.forEach(eventEl => {
            const eventId = eventEl.dataset.eventId;
            if (eventId === undefined) return;
            const eventData = events[parseInt(eventId)];
            if (!eventData) return;
            
            if (eventData.type === 'person') {
                const startPos = ((eventData.birthYear + 4500) / 7000) * 100;
                const endPos = ((eventData.deathYear + 4500) / 7000) * 100;
                let widthPercent = endPos - startPos;
                
                // Ajusta para largura mínima quando necessário
                if (widthPercent < minWidthInPercent) {
                    widthPercent = minWidthInPercent;
                }
                
                eventEl.style.left = `${startPos}%`;
                eventEl.style.width = `${widthPercent}%`;
                adjustPersonBarWidth(eventEl);
            } else if (eventData.type === 'period') {
                const startPos = ((eventData.startYear + 4500) / 7000) * 100;
                const endPos = ((eventData.endYear + 4500) / 7000) * 100;
                const periodWidth = endPos - startPos;
                
                // Garantir largura mínima visível para períodos curtos
                if (periodWidth < 0.3) {
                    eventEl.style.width = '10px'; // Largura mínima fixa para períodos muito curtos
                    eventEl.style.marginLeft = '-5px'; // Centralizar o período
                } else {
                    eventEl.style.width = `${periodWidth}%`;
                    eventEl.style.marginLeft = '0'; // Resetar margin se necessário
                }
                
                eventEl.style.left = `${startPos}%`;
            } else { // event type 'event'
                const position = ((eventData.year + 4500) / 7000) * 100;
                eventEl.style.left = `${position}%`;
            }
        });
        
        document.querySelectorAll('.period-overlay').forEach(periodEl => {
            periodEl.removeEventListener('mouseenter', handlePeriodMouseEnter);
            periodEl.removeEventListener('mouseleave', handlePeriodMouseLeave);
            periodEl.addEventListener('mouseenter', handlePeriodMouseEnter);
            periodEl.addEventListener('mouseleave', handlePeriodMouseLeave);
        });
        
        // Reposiciona as anotações
        repositionAnnotations();
        createDateMarkers();
    });

    let initialPinchDistance = null;
    let initialZoomValue = null;
    timelineContainer.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            e.preventDefault();
            initialPinchDistance = getPinchDistance(e.touches);
            initialZoomValue = currentZoom;
        }
    }, { passive: false });
    timelineContainer.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2 && initialPinchDistance !== null) {
            e.preventDefault();
            const currentDistance = getPinchDistance(e.touches);
            const pinchScale = currentDistance / initialPinchDistance;
            let newZoom = initialZoomValue + (pinchScale - 1) * 50;
            newZoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, newZoom));
            zoomSlider.value = newZoom;
            window.currentZoom = currentZoom = newZoom;
            zoomLabel.textContent = Math.round(newZoom) + '%';
            const actualZoom = Math.pow(2, currentZoom/25);
            const baseWidth = 100;
            timeline.style.width = `${baseWidth * actualZoom}%`;
            
            // Use a mesma lógica melhorada para touch zoom
            const eventElements = document.querySelectorAll('.event');
            const minEventWidth = 40; // Largura mínima em pixels
            const timelineWidth = timeline.offsetWidth;
            const minWidthInPercent = (minEventWidth / timelineWidth) * 100;
            
            eventElements.forEach(eventEl => {
                const eventId = eventEl.dataset.eventId;
                if(eventId === undefined) return;
                const eventData = events[parseInt(eventId)];
                if(!eventData) return;
                
                if (eventData.type === 'person') {
                    const startPos = ((eventData.birthYear + 4500) / 7000) * 100;
                    const endPos = ((eventData.deathYear + 4500) / 7000) * 100;
                    let widthPercent = endPos - startPos;
                    
                    // Ajusta para largura mínima quando necessário
                    if (widthPercent < minWidthInPercent) {
                        widthPercent = minWidthInPercent;
                    }
                    
                    eventEl.style.left = `${startPos}%`;
                    eventEl.style.width = `${widthPercent}%`;
                    adjustPersonBarWidth(eventEl);
                } else if (eventData.type === 'period') {
                    const startPos = ((eventData.startYear + 4500) / 7000) * 100;
                    const endPos = ((eventData.endYear + 4500) / 7000) * 100;
                    const periodWidth = endPos - startPos;
                    
                    // Garantir largura mínima visível para períodos curtos
                    if (periodWidth < 0.3) {
                        eventEl.style.width = '10px'; // Largura mínima fixa para períodos muito curtos
                        eventEl.style.marginLeft = '-5px'; // Centralizar o período
                    } else {
                        eventEl.style.width = `${periodWidth}%`;
                        eventEl.style.marginLeft = '0'; // Resetar margin se necessário
                    }
                    
                    eventEl.style.left = `${startPos}%`;
                } else { // event type 'event'
                    const position = ((eventData.year + 4500) / 7000) * 100;
                    eventEl.style.left = `${position}%`;
                }
            });
            createDateMarkers();
            createVerticalGridLines();
        }
    }, { passive: false });
    timelineContainer.addEventListener('touchend', (e) => {
        if (e.touches.length < 2) {
            initialPinchDistance = null;
            initialZoomValue = null;
        }
    });
    function getPinchDistance(touches) {
        return Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY);
    }

    function enableVerticalDragging() {
        if (window.verticalDragMouseMoveListener) {
            document.removeEventListener('mousemove', window.verticalDragMouseMoveListener);
        }
        if (window.verticalDragMouseUpListener) {
             document.removeEventListener('mouseup', window.verticalDragMouseUpListener);
        }

        const personEvents = document.querySelectorAll('.person-event');
        const rowHeight = 24;

        personEvents.forEach(el => {
            if (el.dataset.verticalDragInitialized === 'true') return;

            el.onmousedown = (e) => {
                if (e.button !== 0 || e.target.closest('.event-content')) return;
                
                // Verifica se o personagem está travado
                const isLocked = el.classList.contains('locked');
                if (isLocked) return; // Se estiver travado, não permite arrastar

                if (document.querySelector('.person-event[data-is-being-dragged="true"]')) return;

                e.preventDefault();
                e.stopPropagation();

                el.dataset.isBeingDragged = 'true';
                el.dataset.startY = e.clientY.toString();
                const computedTop = window.getComputedStyle(el).top;
                el.dataset.startTop = parseFloat(computedTop).toString();
                el.style.transition = 'none';
                document.body.style.cursor = 'grabbing';
                el.style.zIndex = '10000'; 
            };
            el.dataset.verticalDragInitialized = 'true';
        });

        window.verticalDragMouseMoveListener = (e) => {
            const draggedEl = document.querySelector('.person-event[data-is-being-dragged="true"]');
            if (!draggedEl) return;

            const startY = parseFloat(draggedEl.dataset.startY);
            const startTop = parseFloat(draggedEl.dataset.startTop);
            const deltaY = e.clientY - startY;
            draggedEl.style.top = `${startTop + deltaY}px`;
        };

        window.verticalDragMouseUpListener = (e) => {
            const draggedEl = document.querySelector('.person-event[data-is-being-dragged="true"]');
            if (!draggedEl) return;

            draggedEl.style.transition = 'top 0.3s ease';
            document.body.style.cursor = 'default';
            
            const finalTopPixels = parseFloat(draggedEl.style.top) || 0;
            let newCalculatedRow = Math.round((-finalTopPixels - rowHeight) / rowHeight);
            newCalculatedRow = Math.max(0, newCalculatedRow);

            const eventId = parseInt(draggedEl.dataset.eventId);
            const eventData = window.events[eventId];
            let finalRowToSet = newCalculatedRow;

            if (eventData) {
                let overlap = false;
                for (const otherEvent of window.events) {
                    if (otherEvent.type === 'person' && otherEvent !== eventData && otherEvent.personRow === newCalculatedRow) {
                        if (doPeriodsOverlap(eventData.birthYear, eventData.deathYear, otherEvent.birthYear, otherEvent.deathYear)) {
                            overlap = true;
                            break;
                        }
                    }
                }

                if (overlap) {
                    finalRowToSet = eventData.personRow !== undefined ? eventData.personRow : 0;
                } else {
                    eventData.personRow = newCalculatedRow;
                }
            } else {
                finalRowToSet = newCalculatedRow;
            }

            draggedEl.style.setProperty('--person-row', finalRowToSet.toString());
            draggedEl.style.top = `calc(-${rowHeight}px - (${finalRowToSet} * ${rowHeight}px))`;
            draggedEl.style.zIndex = getComputedStyle(draggedEl).getPropertyValue('--person-event-zindex') || '5';


            if (eventData) {
                 localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: window.currentZoom }));
            }

            delete draggedEl.dataset.isBeingDragged;
            delete draggedEl.dataset.startY;
            delete draggedEl.dataset.startTop;

        };

        document.addEventListener('mousemove', window.verticalDragMouseMoveListener);
        document.addEventListener('mouseup', window.verticalDragMouseUpListener);
    }
    enableVerticalDragging();
    
    // Atalhos de teclado
    document.addEventListener('keydown', function(e) {
        // Evita executar atalhos quando estiver em um campo de texto
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        // Alt + E: Adicionar evento
        if (e.altKey && e.key === 'e') {
            e.preventDefault();
            addEventBtn.click();
        }
        
        // Alt + P: Adicionar personagem
        if (e.altKey && e.key === 'p') {
            e.preventDefault();
            addPersonBtn.click();
        }
        
        // Alt + T: Adicionar período
        if (e.altKey && e.key === 't') {
            e.preventDefault();
            addPeriodBtn.click();
        }
        
        // Ctrl + S: Salvar
        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            saveToFile();
        }
        
        // Ctrl + O: Abrir/Carregar
        if (e.ctrlKey && e.key === 'o') {
            e.preventDefault();
            document.querySelector('.load-btn').click();
        }
        
        // Ctrl + I: Exportar para PNG
        if (e.ctrlKey && e.key === 'i') {
            e.preventDefault();
            exportToPNG();
        }
        
        // Ctrl + P: Exportar para PDF
        if (e.ctrlKey && e.key === 'p') {
            e.preventDefault();
            exportToPDF();
        }
        
        // Alt + D: Alternar modo escuro
        if (e.altKey && e.key === 'd') {
            e.preventDefault();
            darkModeItem.click();
        }
        
        // Alt + A: Modo Anotação
        if (e.altKey && e.key === 'a') {
            e.preventDefault();
            document.getElementById('add-annotation-btn').click();
        }
        
        // F1: Ajuda
        if (e.key === 'F1') {
            e.preventDefault();
            helpBtn.click();
        }
        
        // Teclas + e -: Zoom
        if (e.key === '+' || e.key === '=') {
            e.preventDefault();
            const newZoom = Math.min(MAX_ZOOM, currentZoom + 5);
            zoomSlider.value = newZoom;
            zoomSlider.dispatchEvent(new Event('input'));
        }
        
        if (e.key === '-' || e.key === '_') {
            e.preventDefault();
            const newZoom = Math.max(MIN_ZOOM, currentZoom - 5);
            zoomSlider.value = newZoom;
            zoomSlider.dispatchEvent(new Event('input'));
        }
        
        // Setas para navegação
        if (e.key === 'ArrowLeft') {
            e.preventDefault();
            timelineContainer.scrollBy({ left: -100, behavior: 'smooth' });
        }
        
        if (e.key === 'ArrowRight') {
            e.preventDefault();
            timelineContainer.scrollBy({ left: 100, behavior: 'smooth' });
        }
    });
    
    // Captura de tela para PNG
    document.querySelector('.test-img-btn').addEventListener('click', exportToPNG);
    
    function exportToPNG() {
        if (!window.html2canvas) {
            showToast("Biblioteca html2canvas não carregada", "error");
            return;
        }
        
        const target = document.createElement('div');
        target.className = 'pdf-container';
        document.body.appendChild(target);
        
        // Adiciona cabeçalho com título
        const header = document.createElement('div');
        header.className = 'pdf-header';
        header.innerHTML = `
            <h1 class="pdf-title">Linha do Tempo Histórica</h1>
            <div class="pdf-subtitle">Gerado em ${new Date().toLocaleDateString()} às ${new Date().toLocaleTimeString()}</div>
        `;
        target.appendChild(header);
        
        // Clone a linha do tempo
        const timelineClone = timelineContainer.cloneNode(true);
        timelineClone.style.position = 'relative';
        timelineClone.style.height = '500px';
        timelineClone.style.width = '100%';
        timelineClone.style.overflow = 'hidden';
        timelineClone.style.border = '1px solid #ddd';
        timelineClone.style.borderRadius = '8px';
        timelineClone.style.marginBottom = '20px';
        
        target.appendChild(timelineClone);
        
        // Rodapé com informações
        const footer = document.createElement('div');
        footer.style.textAlign = 'right';
        footer.style.margin = '10px 0';
        footer.style.fontSize = '12px';
        footer.style.color = '#777';
        footer.innerHTML = `Criado com Linha do Tempo Histórica • Total de eventos: ${events.length}`;
        target.appendChild(footer);
        
        const popupsToHide = [
            document.getElementById('character-description-popup'),
            document.getElementById('period-description-box')
        ];
        const originalDisplayStyles = popupsToHide.map(p => p ? p.style.display : '');
        popupsToHide.forEach(p => { if (p) p.style.display = 'none'; });
        
        showToast("Gerando imagem...");
        
        html2canvas(target, {
          scale: 2,
          useCORS: true,
          backgroundColor: '#ffffff'
        }).then(canvas => {
          const link = document.createElement('a');
          link.download = 'linha_do_tempo.png';
          link.href = canvas.toDataURL('image/png');
          link.click();
          showToast("Imagem PNG gerada com sucesso");
          document.body.removeChild(target);
        }).catch(err => {
          console.error("Erro ao capturar imagem com html2canvas:", err);
          showToast("Erro ao capturar imagem: " + err.message, "error");
          document.body.removeChild(target);
        }).finally(() => {
            popupsToHide.forEach((p, index) => { if (p) p.style.display = originalDisplayStyles[index]; });
        });
    }
    
    // Configuração para estatísticas
    function updateStatistics() {
        // Contagens básicas
        const totalEvents = events.filter(e => e.type === 'event').length;
        const totalPersons = events.filter(e => e.type === 'person').length;
        const totalPeriods = events.filter(e => e.type === 'period').length;
        
        document.getElementById('total-events').textContent = totalEvents;
        document.getElementById('total-persons').textContent = totalPersons;
        document.getElementById('total-periods').textContent = totalPeriods;
        document.getElementById('total-annotations').textContent = annotations.length;
        
        // Encontrar ano mais antigo e mais recente
        let allYears = [];
        
        events.forEach(event => {
            if (event.type === 'event') {
                allYears.push(event.year);
            } else if (event.type === 'person') {
                allYears.push(event.birthYear, event.deathYear);
            } else if (event.type === 'period') {
                allYears.push(event.startYear, event.endYear);
            }
        });
        
        if (allYears.length > 0) {
            const earliestYear = Math.min(...allYears);
            const latestYear = Math.max(...allYears);
            
            document.getElementById('earliest-year').textContent = formatYear(earliestYear);
            document.getElementById('latest-year').textContent = formatYear(latestYear);
        }
        
        // Criando resumo por séculos
        const centuryContent = document.getElementById('century-content');
        centuryContent.innerHTML = '';
        
        // Função auxiliar para obter o número do século
        function getCentury(year) {
            if (year < 0) {
                return Math.floor(-year / 100) + 1 + "º século A.C.";
            } else {
                return Math.floor((year - 1) / 100) + 1 + "º século D.C.";
            }
        }
        
        // Agrupar eventos por século
        const eventsByCentury = {};
        
        events.forEach(event => {
            let year;
            if (event.type === 'event') {
                year = event.year;
                const century = getCentury(year);
                if (!eventsByCentury[century]) {
                    eventsByCentury[century] = { count: 0, events: [] };
                }
                eventsByCentury[century].count++;
                eventsByCentury[century].events.push(event);
            } else if (event.type === 'person') {
                // Considerar o nascimento da pessoa como ano principal
                year = event.birthYear;
                const century = getCentury(year);
                if (!eventsByCentury[century]) {
                    eventsByCentury[century] = { count: 0, events: [] };
                }
                eventsByCentury[century].count++;
                eventsByCentury[century].events.push(event);
            } else if (event.type === 'period') {
                // Considerar o início do período como ano principal
                year = event.startYear;
                const century = getCentury(year);
                if (!eventsByCentury[century]) {
                    eventsByCentury[century] = { count: 0, events: [] };
                }
                eventsByCentury[century].count++;
                eventsByCentury[century].events.push(event);
            }
        });
        
        // Ordenar séculos
        const sortedCenturies = Object.keys(eventsByCentury).sort((a, b) => {
            const aIsAC = a.includes('A.C.');
            const bIsAC = b.includes('A.C.');
            
            if (aIsAC && !bIsAC) return -1;
            if (!aIsAC && bIsAC) return 1;
            
            const aNum = parseInt(a.match(/\d+/)[0]);
            const bNum = parseInt(b.match(/\d+/)[0]);
            
            if (aIsAC && bIsAC) return bNum - aNum; // Ordem decrescente para A.C.
            return aNum - bNum; // Ordem crescente para D.C.
        });
        
        // Criar cards de século no novo formato
        sortedCenturies.forEach(century => {
            const centuryData = eventsByCentury[century];
            
            // Pegar até 5 eventos principais deste século
            const highlights = centuryData.events
                .sort((a, b) => {
                    // Ordenar por tipo (evento > pessoa > período) e depois por ano
                    if (a.type !== b.type) {
                        if (a.type === 'event') return -1;
                        if (b.type === 'event') return 1;
                        if (a.type === 'person') return -1;
                        if (b.type === 'person') return 1;
                    }
                    
                    const aYear = a.type === 'event' ? a.year : a.type === 'person' ? a.birthYear : a.startYear;
                    const bYear = b.type === 'event' ? b.year : b.type === 'person' ? b.birthYear : b.startYear;
                    
                    return aYear - bYear;
                })
                .slice(0, 5);
            
            const card = document.createElement('div');
            card.className = 'century-card';
            
            // Cabeçalho do card
            const cardHeader = document.createElement('div');
            cardHeader.className = 'century-card-header';
            cardHeader.innerHTML = `
                <div class="century-card-title">${century}</div>
                <div class="century-card-count">${centuryData.count} evento(s)</div>
            `;
            
            // Conteúdo do card
            const cardContent = document.createElement('div');
            cardContent.className = 'century-card-content';
            
            if (highlights.length > 0) {
                highlights.forEach(event => {
                    const year = event.type === 'event' ? event.year : 
                              event.type === 'person' ? event.birthYear : 
                              event.startYear;
                              
                    // Adicionar ícone apropriado para cada tipo de evento
                    let typeIcon = '';
                    if (event.type === 'event') {
                        typeIcon = '<svg viewBox="0 0 24 24" width="16" height="16" style="margin-right: 5px; vertical-align: middle;"><path fill="currentColor" d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"></path></svg>';
                    } else if (event.type === 'person') {
                        typeIcon = '<svg viewBox="0 0 24 24" width="16" height="16" style="margin-right: 5px; vertical-align: middle;"><path fill="currentColor" d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0-6c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm0 7c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z"></path></svg>';
                    } else if (event.type === 'period') {
                        typeIcon = '<svg viewBox="0 0 24 24" width="16" height="16" style="margin-right: 5px; vertical-align: middle;"><path fill="currentColor" d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V9h14v10zm0-12H5V5h14v2zM7 11h5v5H7z"></path></svg>';
                    }
                    
                    const eventItem = document.createElement('div');
                    eventItem.className = 'century-event-item';
                    eventItem.innerHTML = `
                        <div class="century-event-year">${formatYear(year)}</div>
                        <div class="century-event-title">${typeIcon}${sanitizeHtml(event.title)}</div>
                    `;
                    
                    cardContent.appendChild(eventItem);
                });
            } else {
                cardContent.innerHTML = '<div style="font-style: italic; opacity: 0.7;">Sem eventos significativos</div>';
            }
            
            card.appendChild(cardHeader);
            card.appendChild(cardContent);
            centuryContent.appendChild(card);
        });
        
        // Se não houver eventos em nenhum século
        if (sortedCenturies.length === 0) {
            const emptyCard = document.createElement('div');
            emptyCard.className = 'century-card';
            emptyCard.innerHTML = `
                <div class="century-card-header">
                    <div class="century-card-title">Sem dados</div>
                    <div class="century-card-count">0</div>
                </div>
                <div class="century-card-content">
                    <div style="font-style: italic; opacity: 0.7;">Nenhum evento registrado</div>
                </div>
            `;
            centuryContent.appendChild(emptyCard);
        }
    }
    
    // Criar linhas de grade vertical
    function createVerticalGridLines() {
        // Obter o grid e limpar conteúdo anterior
        const grid = document.getElementById('background-grid');
        if (!grid) return;
        grid.innerHTML = '';
        
        // Verificar se as linhas verticais devem ser mostradas
        const showVerticalLines = document.body.classList.contains('show-vertical-lines');
        if (!showVerticalLines) return;
        
        // Obter todas as marcações de data
        const dateMarkers = document.querySelectorAll('.date-marker');
        const minorTicks = document.querySelectorAll('.minor-tick');
        
        // Criar linhas para marcadores principais
        dateMarkers.forEach(marker => {
            const left = marker.style.left;
            if (!left) return;
            
            const line = document.createElement('div');
            line.className = 'vertical-grid-line';
            line.style.left = left;
            grid.appendChild(line);
        });
        
        // Criar linhas para marcadores menores (mais finas ou com opacidade menor)
        minorTicks.forEach(tick => {
            const left = tick.style.left;
            if (!left) return;
            
            const line = document.createElement('div');
            line.className = 'vertical-grid-line';
            line.style.left = left;
            line.style.opacity = '0.5'; // Menos visível que as linhas principais
            grid.appendChild(line);
        });
    }
});

</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>


</body></html>